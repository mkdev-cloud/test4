{
  "Python": {
    "easy": [
      {
        "language": "Python",
        "bugType": "Indentation Error",
        "description": "Incorrect indentation in function (Lang: Python, Q1)",
        "buggyCode": "def greet_user(name):\nprint(f\"Hello, {name}!\")\nprint(\"Welcome to our program!\")",
        "correctCode": "def greet_user(name):\n    print(f\"Hello, {name}!\")\n    print(\"Welcome to our program!\")",
        "hint": "Python requires proper indentation for function bodies"
      },
      {
        "language": "Python",
        "bugType": "Logic Error",
        "description": "Wrong comparison operator (Lang: Python, Q2)",
        "buggyCode": "def can_vote(age):\n    if age > 18:\n        return True\n    return False",
        "correctCode": "def can_vote(age):\n    if age >= 18:\n        return True\n    return False",
        "hint": "Should people exactly 18 years old be able to vote?"
      },
      {
        "language": "Python",
        "bugType": "Syntax Error",
        "description": "Missing colon after if statement (Lang: Python, Q3)",
        "buggyCode": "def check_positive(num):\n    if num > 0\n        return \"Positive\"\n    else:\n        return \"Not positive\"",
        "correctCode": "def check_positive(num):\n    if num > 0:\n        return \"Positive\"\n    else:\n        return \"Not positive\"",
        "hint": "Python if statements need a colon (:) at the end"
      },
      {
        "language": "Python",
        "bugType": "Type Error",
        "description": "Concatenating string with integer (Lang: Python, Q4)",
        "buggyCode": "age = 30\nmessage = \"I am \" + age + \" years old.\"",
        "correctCode": "age = 30\nmessage = \"I am \" + str(age) + \" years old.\"",
        "hint": "You cannot concatenate a string and an integer directly in Python."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Dangerous mutable default parameter (Lang: Python, Q5)",
        "buggyCode": "def add_item(item, shopping_list=[]):\n    shopping_list.append(item)\n    return shopping_list",
        "correctCode": "def add_item(item, shopping_list=None):\n    if shopping_list is None:\n        shopping_list = []\n    shopping_list.append(item)\n    return shopping_list",
        "hint": "Mutable default arguments are shared between function calls."
      },
      {
        "language": "Python",
        "bugType": "Indentation Error",
        "description": "Incorrect indentation in function (Lang: Python, Q6)",
        "buggyCode": "def greet_user(name):\nprint(f\"Hello, {name}!\")",
        "correctCode": "def greet_user(name):\n    print(f\"Hello, {name}!\")",
        "hint": "Python requires proper indentation for function bodies."
      },
      {
        "language": "Python",
        "bugType": "Logic Error",
        "description": "Wrong comparison operator (Lang: Python, Q7)",
        "buggyCode": "def can_vote(age):\n    if age > 18:\n        return True\n    return False",
        "correctCode": "def can_vote(age):\n    if age >= 18:\n        return True\n    return False",
        "hint": "Should people exactly 18 years old be able to vote?"
      },
      {
        "language": "Python",
        "bugType": "Syntax Error",
        "description": "Missing colon after if statement (Lang: Python, Q8)",
        "buggyCode": "def check_positive(num):\n    if num > 0\n        return \"Positive\"",
        "correctCode": "def check_positive(num):\n    if num > 0:\n        return \"Positive\"",
        "hint": "Python if statements need a colon (:) at the end."
      },
      {
        "language": "Python",
        "bugType": "Type Error",
        "description": "Concatenating string with integer (Lang: Python, Q9)",
        "buggyCode": "value = 10\ntext = \"Number: \" + value",
        "correctCode": "value = 10\ntext = \"Number: \" + str(value)",
        "hint": "Convert integer to string before concatenation."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Dangerous mutable default parameter (Lang: Python, Q10)",
        "buggyCode": "def log_message(msg, logs=[]):\n    logs.append(msg)\n    return logs",
        "correctCode": "def log_message(msg, logs=None):\n    if logs is None:\n        logs = []\n    logs.append(msg)\n    return logs",
        "hint": "Default parameters are evaluated once."
      },
      {
        "language": "Python",
        "bugType": "Syntax Error",
        "description": "Missing parenthesis in print (Lang: Python, Q11)",
        "buggyCode": "print \"Hello Python\"",
        "correctCode": "print(\"Hello Python\")",
        "hint": "Print is a function in Python 3."
      },
      {
        "language": "Python",
        "bugType": "Logic Error",
        "description": "Incorrect loop range (Lang: Python, Q12)",
        "buggyCode": "for i in range(5):\n    print(i)",
        "correctCode": "for i in range(1, 6):\n    print(i)",
        "hint": "range(n) goes from 0 to n-1."
      },
      {
        "language": "Python",
        "bugType": "Indentation Error",
        "description": "Missing indentation for class method (Lang: Python, Q13)",
        "buggyCode": "class MyClass:\n  def my_method():\n    pass",
        "correctCode": "class MyClass:\n    def my_method():\n        pass",
        "hint": "Class methods require proper indentation."
      },
      {
        "language": "Python",
        "bugType": "Type Error",
        "description": "Incorrect dictionary key access (Lang: Python, Q14)",
        "buggyCode": "data = {'name': 'Alice'}\nprint(data['Name'])",
        "correctCode": "data = {'name': 'Alice'}\nprint(data['name'])",
        "hint": "Dictionary keys are case-sensitive."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Using list comprehension for mutable default (Lang: Python, Q15)",
        "buggyCode": "def process_data(data, config={}):\n    config['processed'] = True\n    return config",
        "correctCode": "def process_data(data, config=None):\n    if config is None:\n        config = {}\n    config['processed'] = True\n    return config",
        "hint": "Default arguments are evaluated once at function definition."
      },
      {
        "language": "Python",
        "bugType": "Syntax Error",
        "description": "Unmatched quote (Lang: Python, Q16)",
        "buggyCode": "print('This is a string\")",
        "correctCode": "print('This is a string')",
        "hint": "Ensure quotes are matched correctly."
      },
      {
        "language": "Python",
        "bugType": "Logic Error",
        "description": "Incorrect boolean logic (Lang: Python, Q17)",
        "buggyCode": "is_admin = False\nis_editor = True\nif is_admin or is_editor and not is_admin:\n    print('Access granted')",
        "correctCode": "is_admin = False\nis_editor = True\nif is_admin or (is_editor and not is_admin):\n    print('Access granted')",
        "hint": "Understand operator precedence (and before or)."
      },
      {
        "language": "Python",
        "bugType": "Indentation Error",
        "description": "Incorrect indentation after function call (Lang: Python, Q18)",
        "buggyCode": "if True:\n    print('Inside if')\n print('Outside if')",
        "correctCode": "if True:\n    print('Inside if')\nprint('Outside if')",
        "hint": "Code blocks must have consistent indentation."
      },
      {
        "language": "Python",
        "bugType": "Type Error",
        "description": "Attempting to modify a tuple (Lang: Python, Q19)",
        "buggyCode": "my_tuple = (1, 2, 3)\nmy_tuple[0] = 4",
        "correctCode": "my_list = [1, 2, 3]\nmy_list[0] = 4",
        "hint": "Tuples are immutable; use a list for mutable sequences."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Replicated Mutable Default Argument (Lang: Python, Q20)",
        "buggyCode": "def process_data(data, config={}):\n    config['processed'] = True\n    return config",
        "correctCode": "def process_data(data, config=None):\n    if config is None:\n        config = {}\n    config['processed'] = True\n    return config",
        "hint": "Default arguments are evaluated once at function definition."
      }
    ],
    "medium": [
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Dangerous mutable default parameter (Lang: Python, Q1)",
        "buggyCode": "def add_item(item, shopping_list=[]):\n    shopping_list.append(item)\n    return shopping_list",
        "correctCode": "def add_item(item, shopping_list=None):\n    if shopping_list is None:\n        shopping_list = []\n    shopping_list.append(item)\n    return shopping_list",
        "hint": "Mutable default arguments are shared between function calls."
      },
      {
        "language": "Python",
        "bugType": "Closures/Late Binding",
        "description": "Late binding in loops with closures (Lang: Python, Q2)",
        "buggyCode": "funcs = []\nfor i in range(3):\n    def f():\n        print(i)\n    funcs.append(f)\nfor f in funcs:\n    f()",
        "correctCode": "funcs = []\nfor i in range(3):\n    def f(j=i):\n        print(j)\n    funcs.append(f)\nfor f in funcs:\n    f()",
        "hint": "Variables in closures are bound at call time, not definition time. Use default arguments to capture loop variable."
      },
      {
        "language": "Python",
        "bugType": "Shallow Copy",
        "description": "Modifying a shallow copy (Lang: Python, Q3)",
        "buggyCode": "original = [[1, 2], [3, 4]]\ncopy = list(original)\ncopy[0][0] = 99",
        "correctCode": "import copy\noriginal = [[1, 2], [3, 4]]\ncopy_deep = copy.deepcopy(original)\ncopy_deep[0][0] = 99",
        "hint": "List slicing creates a shallow copy. Nested lists are still references."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Dangerous mutable default parameter (Lang: Python, Q4)",
        "buggyCode": "def cache_result(arg, cache={}):\n    if arg in cache:\n        return cache[arg]\n    result = arg * 2\n    cache[arg] = result\n    return result",
        "correctCode": "def cache_result(arg, cache=None):\n    if cache is None:\n        cache = {}\n    if arg in cache:\n        return cache[arg]\n    result = arg * 2\n    cache[arg] = result\n    return result",
        "hint": "Default parameters are evaluated once."
      },
      {
        "language": "Python",
        "bugType": "Closures/Late Binding",
        "description": "Late binding in loops with closures (Lang: Python, Q5)",
        "buggyCode": "actions = []\nfor x in [1, 2, 3]:\n    actions.append(lambda: x * 2)\nprint([action() for action in actions])",
        "correctCode": "actions = []\nfor x in [1, 2, 3]:\n    actions.append(lambda val=x: val * 2)\nprint([action() for action in actions])",
        "hint": "Lambda functions capture `x` by reference, not by value."
      },
      {
        "language": "Python",
        "bugType": "Shallow Copy",
        "description": "Modifying a shallow copy (Lang: Python, Q6)",
        "buggyCode": "list_of_lists = [[1], [2], [3]]\ncopy_list = list_of_lists[:]\ncopy_list[0].append(9)",
        "correctCode": "import copy\nlist_of_lists = [[1], [2], [3]]\ndeep_copy_list = copy.deepcopy(list_of_lists)\ndeep_copy_list[0].append(9)",
        "hint": "A shallow copy duplicates the list, but not the objects within it."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Dangerous mutable default parameter (Lang: Python, Q7)",
        "buggyCode": "def process_names(name, processed_names=[]):\n    processed_names.append(name.upper())\n    return processed_names",
        "correctCode": "def process_names(name, processed_names=None):\n    if processed_names is None:\n        processed_names = []\n    processed_names.append(name.upper())\n    return processed_names",
        "hint": "Avoid mutable defaults; they lead to unexpected state sharing."
      },
      {
        "language": "Python",
        "bugType": "Closures/Late Binding",
        "description": "Late binding in loops with closures (Lang: Python, Q8)",
        "buggyCode": "def make_multipliers():\n    return [lambda x: i * x for i in range(4)]\nmultipliers = make_multipliers()\nprint([m(2) for m in multipliers])",
        "correctCode": "def make_multipliers():\n    return [lambda x, i=i: i * x for i in range(4)]\nmultipliers = make_multipliers()\nprint([m(2) for m in multipliers])",
        "hint": "Use a default argument to bind the loop variable's value."
      },
      {
        "language": "Python",
        "bugType": "Shallow Copy",
        "description": "Modifying a shallow copy (Lang: Python, Q9)",
        "buggyCode": "dict1 = {'a': [1,2]}\ndict2 = dict1.copy()\ndict2['a'].append(3)",
        "correctCode": "import copy\ndict1 = {'a': [1,2]}\ndict2 = copy.deepcopy(dict1)\ndict2['a'].append(3)",
        "hint": "Use `copy.deepcopy` for nested mutable objects."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Dangerous mutable default parameter (Lang: Python, Q10)",
        "buggyCode": "def create_object(name, attributes={}):\n    attributes['timestamp'] = 'now'\n    return attributes",
        "correctCode": "def create_object(name, attributes=None):\n    if attributes is None:\n        attributes = {}\n    attributes['timestamp'] = 'now'\n    return attributes",
        "hint": "Default mutable arguments persist across calls."
      },
      {
        "language": "Python",
        "bugType": "Closures/Late Binding",
        "description": "Late binding in loops with closures (Lang: Python, Q11)",
        "buggyCode": "def factory():\n    functions = []\n    for j in range(3):\n        functions.append(lambda: j)\n    return functions\nfuncs = factory()\nprint([f() for f in funcs])",
        "correctCode": "def factory():\n    functions = []\n    for j in range(3):\n        functions.append(lambda val=j: val)\n    return functions\nfuncs = factory()\nprint([f() for f in funcs])",
        "hint": "The value of `j` is looked up when the lambda is called."
      },
      {
        "language": "Python",
        "bugType": "Shallow Copy",
        "description": "Modifying a shallow copy (Lang: Python, Q12)",
        "buggyCode": "matrix = [[1, 2], [3, 4]]\nnew_matrix = matrix[:]\nnew_matrix[0][0] = 0",
        "correctCode": "import copy\nmatrix = [[1, 2], [3, 4]]\nnew_matrix = copy.deepcopy(matrix)\nnew_matrix[0][0] = 0",
        "hint": "For nested structures, shallow copy isn't enough."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Dangerous mutable default parameter (Lang: Python, Q13)",
        "buggyCode": "def add_log_entry(entry, log_entries=[]):\n    log_entries.append(entry)\n    return log_entries",
        "correctCode": "def add_log_entry(entry, log_entries=None):\n    if log_entries is None:\n        log_entries = []\n    log_entries.append(entry)\n    return log_entries",
        "hint": "Default mutable arguments are shared across function calls."
      },
      {
        "language": "Python",
        "bugType": "Closures/Late Binding",
        "description": "Late binding in loops with closures (Lang: Python, Q14)",
        "buggyCode": "callbacks = []\nfor k in range(5):\n    callbacks.append(lambda: k*k)\nprint([cb() for cb in callbacks])",
        "correctCode": "callbacks = []\nfor k in range(5):\n    callbacks.append(lambda val=k: val*val)\nprint([cb() for cb in callbacks])",
        "hint": "Capture the loop variable's value at each iteration."
      },
      {
        "language": "Python",
        "bugType": "Shallow Copy",
        "description": "Modifying a shallow copy (Lang: Python, Q15)",
        "buggyCode": "nested_dict = {'data': {'value': 10}}\ncopy_dict = nested_dict.copy()\ncopy_dict['data']['value'] = 20",
        "correctCode": "import copy\nnested_dict = {'data': {'value': 10}}\ncopy_dict = copy.deepcopy(nested_dict)\ncopy_dict['data']['value'] = 20",
        "hint": "`.copy()` creates a shallow copy, nested objects are still linked."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Dangerous mutable default parameter (Lang: Python, Q16)",
        "buggyCode": "def configure_app(settings={}):\n    settings['configured'] = True\n    return settings",
        "correctCode": "def configure_app(settings=None):\n    if settings is None:\n        settings = {}\n    settings['configured'] = True\n    return settings",
        "hint": "Mutable default parameters can lead to unexpected state changes."
      },
      {
        "language": "Python",
        "bugType": "Closures/Late Binding",
        "description": "Late binding in loops with closures (Lang: Python, Q17)",
        "buggyCode": "def get_multipliers():\n    multipliers = []\n    for factor in range(1, 4):\n        multipliers.append(lambda x: x * factor)\n    return multipliers\nfuncs = get_multipliers()\nprint([f(5) for f in funcs])",
        "correctCode": "def get_multipliers():\n    multipliers = []\n    for factor in range(1, 4):\n        multipliers.append(lambda x, f=factor: x * f)\n    return multipliers\nfuncs = get_multipliers()\nprint([f(5) for f in funcs])",
        "hint": "Use a default argument in lambda to capture the variable's value."
      },
      {
        "language": "Python",
        "bugType": "Shallow Copy",
        "description": "Modifying a shallow copy (Lang: Python, Q18)",
        "buggyCode": "set_of_lists = [{1}, {2}, {3}]\ncopy_set = set_of_lists.copy()\nlist(copy_set)[0].add(4)",
        "correctCode": "import copy\nset_of_lists = [{1}, {2}, {3}]\ncopy_set = copy.deepcopy(set_of_lists)\nlist(copy_set)[0].add(4)",
        "hint": "Sets containing mutable objects require deep copy for independent modification."
      },
      {
        "language": "Python",
        "bugType": "Mutable Default Argument",
        "description": "Dangerous mutable default parameter (Lang: Python, Q19)",
        "buggyCode": "def add_to_set(element, current_set=set()):\n    current_set.add(element)\n    return current_set",
        "correctCode": "def add_to_set(element, current_set=None):\n    if current_set is None:\n        current_set = set()\n    current_set.add(element)\n    return current_set",
        "hint": "Default sets are mutable and shared across calls."
      },
      {
        "language": "Python",
        "bugType": "Closures/Late Binding",
        "description": "Late binding in loops with closures (Lang: Python, Q20)",
        "buggyCode": "def generate_greeters():\n    greeters = []\n    for name in ['Alice', 'Bob']:\n        greeters.append(lambda: f'Hello, {name}')\n    return greeters\nfuncs = generate_greeters()\nprint([f() for f in funcs])",
        "correctCode": "def generate_greeters():\n    greeters = []\n    for name in ['Alice', 'Bob']:\n        greeters.append(lambda n=name: f'Hello, {n}')\n    return greeters\nfuncs = generate_greeters()\nprint([f() for f in funcs])",
        "hint": "Capture the `name` variable's value for each lambda."
      }
    ],
    "hard": [
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q1)",
        "buggyCode": "import threading\n\ncounter = 0\ndef increment():\n    global counter\n    for _ in range(100000):\n        counter += 1\n\nthreads = [threading.Thread(target=increment) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final counter: {counter}\")",
        "correctCode": "import threading\n\ncounter = 0\nlock = threading.Lock()\ndef increment():\n    global counter\n    for _ in range(100000):\n        with lock:\n            counter += 1\n\nthreads = [threading.Thread(target=increment) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final counter: {counter}\")",
        "hint": "Shared resources in multi-threaded environments need synchronization mechanisms like locks."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference preventing garbage collection (Lang: Python, Q2)",
        "buggyCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.prev = None\n\nn1 = Node(1)\nn2 = Node(2)\nn1.next = n2\nn2.prev = n1\n\ndel n1\ndel n2\nimport gc\ngc.collect()\nprint(len(gc.get_objects())) # Object count might not decrease",
        "correctCode": "import weakref\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.prev = None\n\n    def __del__(self):\n        print(f\"Deleting Node {self.value}\")\n\nn1 = Node(1)\nn2 = Node(2)\nn1.next = n2\nn2.prev = weakref.ref(n1) # Use weak reference for back-pointer\n\ndel n1\ndel n2\nimport gc\ngc.collect()\nprint(len(gc.get_objects()))",
        "hint": "Circular references can prevent garbage collection. Use `weakref` for back-references."
      },
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q3)",
        "buggyCode": "import threading\n\ncount = {'value': 0}\ndef add_to_count():\n    for _ in range(100000):\n        count['value'] += 1\n\nthreads = [threading.Thread(target=add_to_count) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final count: {count['value']}\")",
        "correctCode": "import threading\n\ncount = {'value': 0}\nlock = threading.Lock()\ndef add_to_count():\n    for _ in range(100000):\n        with lock:\n            count['value'] += 1\n\nthreads = [threading.Thread(target=add_to_count) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final count: {count['value']}\")",
        "hint": "Python's Global Interpreter Lock (GIL) doesn't protect against race conditions on mutable objects."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference in linked list (Lang: Python, Q4)",
        "buggyCode": "class LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n    def set_next(self, node):\n        self.next = node\n\nnode1 = LinkedListNode(1)\nnode2 = LinkedListNode(2)\nnode1.set_next(node2)\nnode2.set_next(node1) # Creates circular reference\n\ndel node1\ndel node2\nimport gc\ngc.collect()",
        "correctCode": "import weakref\n\nclass LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n    def set_next(self, node):\n        self.next = node\n\nnode1 = LinkedListNode(1)\nnode2 = LinkedListNode(2)\nnode1.set_next(node2)\n# node2.set_next(weakref.ref(node1)) # No direct circular ref for simple lists\n\ndel node1\ndel node2\nimport gc\ngc.collect()",
        "hint": "Circular references in objects can prevent them from being garbage collected. Break the cycle."
      },
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q5)",
        "buggyCode": "import threading\n\nshared_data = [0]\ndef modify_data():\n    for _ in range(100000):\n        shared_data[0] += 1\n\nthreads = [threading.Thread(target=modify_data) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final data: {shared_data[0]}\")",
        "correctCode": "import threading\n\nshared_data = [0]\nlock = threading.Lock()\ndef modify_data():\n    for _ in range(100000):\n        with lock:\n            shared_data[0] += 1\n\nthreads = [threading.Thread(target=modify_data) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final data: {shared_data[0]}\")",
        "hint": "Use a lock to protect access to shared mutable data across threads."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference preventing garbage collection (Lang: Python, Q6)",
        "buggyCode": "class A:\n    def __init__(self):\n        self.b = None\nclass B:\n    def __init__(self):\n        self.a = None\n\na = A()\nb = B()\na.b = b\nb.a = a\n\ndel a\ndel b\nimport gc\ngc.collect()",
        "correctCode": "import weakref\n\nclass A:\n    def __init__(self):\n        self.b = None\nclass B:\n    def __init__(self):\n        self.a = None\n\na = A()\nb = B()\na.b = b\nb.a = weakref.ref(a) # Break circular reference\n\ndel a\ndel b\nimport gc\ngc.collect()",
        "hint": "Weak references allow objects to be garbage collected even if referenced."
      },
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q7)",
        "buggyCode": "import threading\n\nvalue = 0\n\ndef increment_value():\n    global value\n    for _ in range(100000):\n        temp = value\n        value = temp + 1\n\nthreads = [threading.Thread(target=increment_value) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final value: {value}\")",
        "correctCode": "import threading\n\nvalue = 0\nlock = threading.Lock()\n\ndef increment_value():\n    global value\n    for _ in range(100000):\n        with lock:\n            temp = value\n            value = temp + 1\n\nthreads = [threading.Thread(target=increment_value) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final value: {value}\")",
        "hint": "Operations involving reading, modifying, and writing shared variables are not atomic."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference preventing garbage collection (Lang: Python, Q8)",
        "buggyCode": "class Parent:\n    def __init__(self, child):\n        self.child = child\nclass Child:\n    def __init__(self, parent):\n        self.parent = parent\n\np = Parent(None)\nc = Child(p)\np.child = c\n\ndel p\ndel c\nimport gc\ngc.collect()",
        "correctCode": "import weakref\n\nclass Parent:\n    def __init__(self, child):\n        self.child = child\nclass Child:\n    def __init__(self, parent_ref):\n        self.parent = parent_ref\n\np = Parent(None)\nc = Child(weakref.ref(p))\np.child = c\n\ndel p\ndel c\nimport gc\ngc.collect()",
        "hint": "Use `weakref.ref` for references that should not prevent garbage collection."
      },
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q9)",
        "buggyCode": "import threading\n\ndata_list = []\ndef append_data():\n    for i in range(10000):\n        data_list.append(i)\n\nthreads = [threading.Thread(target=append_data) for _ in range(10)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"List length: {len(data_list)}\")",
        "correctCode": "import threading\n\ndata_list = []\nlock = threading.Lock()\ndef append_data():\n    for i in range(10000):\n        with lock:\n            data_list.append(i)\n\nthreads = [threading.Thread(target=append_data) for _ in range(10)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"List length: {len(data_list)}\")",
        "hint": "Operations on shared mutable lists (`.append()`) are not inherently thread-safe."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference preventing garbage collection (Lang: Python, Q10)",
        "buggyCode": "class ClassA:\n    def __init__(self):\n        self.connected_obj = None\nclass ClassB:\n    def __init__(self):\n        self.connected_obj = None\n\no1 = ClassA()\no2 = ClassB()\no1.connected_obj = o2\no2.connected_obj = o1\n\ndel o1\ndel o2\nimport gc\ngc.collect()",
        "correctCode": "import weakref\n\nclass ClassA:\n    def __init__(self):\n        self.connected_obj = None\nclass ClassB:\n    def __init__(self):\n        self.connected_obj = None\n\no1 = ClassA()\no2 = ClassB()\no1.connected_obj = o2\no2.connected_obj = weakref.ref(o1)\n\ndel o1\ndel o2\nimport gc\ngc.collect()",
        "hint": "Break circular references to allow objects to be garbage collected."
      },
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q11)",
        "buggyCode": "import threading\n\ncounter = 0\ndef increment():\n    global counter\n    for _ in range(100000):\n        counter += 1\n\nthreads = [threading.Thread(target=increment) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final counter: {counter}\")",
        "correctCode": "import threading\n\ncounter = 0\nlock = threading.Lock()\ndef increment():\n    global counter\n    for _ in range(100000):\n        with lock:\n            counter += 1\n\nthreads = [threading.Thread(target=increment) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final counter: {counter}\")",
        "hint": "Shared resources in multi-threaded environments need synchronization mechanisms like locks."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference preventing garbage collection (Lang: Python, Q12)",
        "buggyCode": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.prev = None\n\nn1 = Node(1)\nn2 = Node(2)\nn1.next = n2\nn2.prev = n1\n\ndel n1\ndel n2\nimport gc\ngc.collect()\nprint(len(gc.get_objects()))",
        "correctCode": "import weakref\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.prev = None\n\n    def __del__(self):\n        print(f\"Deleting Node {self.value}\")\n\nn1 = Node(1)\nn2 = Node(2)\nn1.next = n2\nn2.prev = weakref.ref(n1)\n\ndel n1\ndel n2\nimport gc\ngc.collect()\nprint(len(gc.get_objects()))",
        "hint": "Circular references can prevent garbage collection. Use `weakref` for back-references."
      },
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q13)",
        "buggyCode": "import threading\n\ncount = {'value': 0}\ndef add_to_count():\n    for _ in range(100000):\n        count['value'] += 1\n\nthreads = [threading.Thread(target=add_to_count) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final count: {count['value']}\")",
        "correctCode": "import threading\n\ncount = {'value': 0}\nlock = threading.Lock()\ndef add_to_count():\n    for _ in range(100000):\n        with lock:\n            count['value'] += 1\n\nthreads = [threading.Thread(target=add_to_count) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final count: {count['value']}\")",
        "hint": "Python's Global Interpreter Lock (GIL) doesn't protect against race conditions on mutable objects."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference in linked list (Lang: Python, Q14)",
        "buggyCode": "class LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n    def set_next(self, node):\n        self.next = node\n\nnode1 = LinkedListNode(1)\nnode2 = LinkedListNode(2)\nnode1.set_next(node2)\nnode2.set_next(node1)",
        "correctCode": "import weakref\n\nclass LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n    def set_next(self, node):\n        self.next = node\n\nnode1 = LinkedListNode(1)\nnode2 = LinkedListNode(2)\nnode1.set_next(node2)\n# node2.set_next(weakref.ref(node1))",
        "hint": "Circular references can prevent objects from being garbage collected. Break the cycle."
      },
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q15)",
        "buggyCode": "import threading\n\nshared_data = [0]\ndef modify_data():\n    for _ in range(100000):\n        shared_data[0] += 1\n\nthreads = [threading.Thread(target=modify_data) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final data: {shared_data[0]}\")",
        "correctCode": "import threading\n\nshared_data = [0]\nlock = threading.Lock()\ndef modify_data():\n    for _ in range(100000):\n        with lock:\n            shared_data[0] += 1\n\nthreads = [threading.Thread(target=modify_data) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final data: {shared_data[0]}\")",
        "hint": "Use a lock to protect access to shared mutable data across threads."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference preventing garbage collection (Lang: Python, Q16)",
        "buggyCode": "class A:\n    def __init__(self):\n        self.b = None\nclass B:\n    def __init__(self):\n        self.a = None\n\na = A()\nb = B()\na.b = b\nb.a = a\n\ndel a\ndel b\nimport gc\ngc.collect()",
        "correctCode": "import weakref\n\nclass A:\n    def __init__(self):\n        self.b = None\nclass B:\n    def __init__(self):\n        self.a = None\n\na = A()\nb = B()\na.b = b\nb.a = weakref.ref(a)\n\ndel a\ndel b\nimport gc\ngc.collect()",
        "hint": "Weak references allow objects to be garbage collected even if referenced."
      },
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q17)",
        "buggyCode": "import threading\n\nvalue = 0\n\ndef increment_value():\n    global value\n    for _ in range(100000):\n        temp = value\n        value = temp + 1\n\nthreads = [threading.Thread(target=increment_value) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final value: {value}\")",
        "correctCode": "import threading\n\nvalue = 0\nlock = threading.Lock()\n\ndef increment_value():\n    global value\n    for _ in range(100000):\n        with lock:\n            temp = value\n            value = temp + 1\n\nthreads = [threading.Thread(target=increment_value) for _ in range(5)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"Final value: {value}\")",
        "hint": "Operations involving reading, modifying, and writing shared variables are not atomic."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference preventing garbage collection (Lang: Python, Q18)",
        "buggyCode": "class Parent:\n    def __init__(self, child):\n        self.child = child\nclass Child:\n    def __init__(self, parent):\n        self.parent = parent\n\np = Parent(None)\nc = Child(p)\np.child = c\n\ndel p\ndel c\nimport gc\ngc.collect()",
        "correctCode": "import weakref\n\nclass Parent:\n    def __init__(self, child):\n        self.child = child\nclass Child:\n    def __init__(self, parent_ref):\n        self.parent = parent_ref\n\np = Parent(None)\nc = Child(weakref.ref(p))\np.child = c\n\ndel p\ndel c\nimport gc\ngc.collect()",
        "hint": "Use `weakref.ref` for references that should not prevent garbage collection."
      },
      {
        "language": "Python",
        "bugType": "Concurrency Issue",
        "description": "Race condition in thread unsafe counter (Lang: Python, Q19)",
        "buggyCode": "import threading\n\ndata_list = []\ndef append_data():\n    for i in range(10000):\n        data_list.append(i)\n\nthreads = [threading.Thread(target=append_data) for _ in range(10)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"List length: {len(data_list)}\")",
        "correctCode": "import threading\n\ndata_list = []\nlock = threading.Lock()\ndef append_data():\n    for i in range(10000):\n        with lock:\n            data_list.append(i)\n\nthreads = [threading.Thread(target=append_data) for _ in range(10)]\nfor t in threads: t.start()\nfor t in threads: t.join()\nprint(f\"List length: {len(data_list)}\")",
        "hint": "Operations on shared mutable lists (`.append()`) are not inherently thread-safe."
      },
      {
        "language": "Python",
        "bugType": "Memory Leak",
        "description": "Circular reference preventing garbage collection (Lang: Python, Q20)",
        "buggyCode": "class ClassA:\n    def __init__(self):\n        self.connected_obj = None\nclass ClassB:\n    def __init__(self):\n        self.connected_obj = None\n\no1 = ClassA()\no2 = ClassB()\no1.connected_obj = o2\no2.connected_obj = o1\n\ndel o1\ndel o2\nimport gc\ngc.collect()",
        "correctCode": "import weakref\n\nclass ClassA:\n    def __init__(self):\n        self.connected_obj = None\nclass ClassB:\n    def __init__(self):\n        self.connected_obj = None\n\no1 = ClassA()\no2 = ClassB()\no1.connected_obj = o2\no2.connected_obj = weakref.ref(o1)\n\ndel o1\ndel o2\nimport gc\ngc.collect()",
        "hint": "Break circular references to allow objects to be garbage collected."
      }
    ]
  },
  "JavaScript": {
    "easy": [
      {
        "language": "JavaScript",
        "bugType": "Logic Error",
        "description": "Wrong comparison operator (Lang: JavaScript, Q1)",
        "buggyCode": "function canVote(age) {\n    if (age > 18) {\n        return true;\n    }\n    return false;\n}",
        "correctCode": "function canVote(age) {\n    if (age >= 18) {\n        return true;\n    }\n    return false;\n}",
        "hint": "Should people exactly 18 years old be able to vote?"
      },
      {
        "language": "JavaScript",
        "bugType": "Runtime Error",
        "description": "Accessing property of undefined object (Lang: JavaScript, Q2)",
        "buggyCode": "let user;\nconsole.log(user.name);",
        "correctCode": "let user = { name: \"John Doe\" };\nconsole.log(user.name);",
        "hint": "The 'user' variable is not initialized."
      },
      {
        "language": "JavaScript",
        "bugType": "Scope Issue",
        "description": "Variable declared with var in a loop (Lang: JavaScript, Q3)",
        "buggyCode": "for (var i = 0; i < 3; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000);\n}",
        "correctCode": "for (let i = 0; i < 3; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000);\n}",
        "hint": "Consider block-scoping with variable scoping - use let instead of var."
      },
      {
        "language": "JavaScript",
        "bugType": "Async/Promise Error",
        "description": "Missing await in async function (Lang: JavaScript, Q4)",
        "buggyCode": "async function fetchUserData(userId) {\n    try {\n        let response = fetch(`/api/users/${userId}`);\n        let userData = response.json();\n        return userData.name;\n    } catch (error) {\n        return \"Error loading user\";\n    }\n}",
        "correctCode": "async function fetchUserData(userId) {\n    try {\n        let response = await fetch(`/api/users/${userId}`);\n        let userData = await response.json();\n        return userData.name;\n    } catch (error) {\n        return \"Error loading user\";\n    }\n}",
        "hint": "Fetching data and parsing JSON are asynchronous operations."
      },
      {
        "language": "JavaScript",
        "bugType": "Logic Error",
        "description": "Incorrect array length check (Lang: JavaScript, Q5)",
        "buggyCode": "function isEmpty(arr) {\n    return arr.length == 0;\n}",
        "correctCode": "function isEmpty(arr) {\n    return arr && arr.length === 0;\n}",
        "hint": "What if the array is null or undefined?"
      },
      {
        "language": "JavaScript",
        "bugType": "Runtime Error",
        "description": "Calling method on null (Lang: JavaScript, Q6)",
        "buggyCode": "let data = null;\nconsole.log(data.toString());",
        "correctCode": "let data = {};\nconsole.log(data.toString());",
        "hint": "Cannot read properties of null (reading 'toString')."
      },
      {
        "language": "JavaScript",
        "bugType": "Scope Issue",
        "description": "Variable declared with var in a loop causing unexpected behavior (Lang: JavaScript, Q7)",
        "buggyCode": "const buttons = document.querySelectorAll('button');\nfor (var i = 0; i < buttons.length; i++) {\n    buttons[i].onclick = function() {\n        console.log('Button ' + i + ' clicked');\n    };\n}",
        "correctCode": "const buttons = document.querySelectorAll('button');\nfor (let i = 0; i < buttons.length; i++) {\n    buttons[i].onclick = function() {\n        console.log('Button ' + i + ' clicked');\n    };\n}",
        "hint": "Closures over `var` variables capture the variable itself, not its value at each iteration."
      },
      {
        "language": "JavaScript",
        "bugType": "Async/Promise Error",
        "description": "Forgetting to await a promise (Lang: JavaScript, Q8)",
        "buggyCode": "async function processData() {\n    let result = Promise.resolve(10);\n    console.log(result);\n}",
        "correctCode": "async function processData() {\n    let result = await Promise.resolve(10);\n    console.log(result);\n}",
        "hint": "To get the resolved value of a Promise, you need to `await` it."
      },
      {
        "language": "JavaScript",
        "bugType": "Logic Error",
        "description": "Incorrect conditional for string check (Lang: JavaScript, Q9)",
        "buggyCode": "function checkString(str) {\n    if (str == 'hello') {\n        return true;\n    }\n    return false;\n}",
        "correctCode": "function checkString(str) {\n    if (str === 'hello') {\n        return true;\n    }\n    return false;\n}",
        "hint": "Use strict equality (===) to avoid type coercion."
      },
      {
        "language": "JavaScript",
        "bugType": "Runtime Error",
        "description": "Typo in method name (Lang: JavaScript, Q10)",
        "buggyCode": "let arr = [1, 2, 3];\narr.pushh(4);",
        "correctCode": "let arr = [1, 2, 3];\narr.push(4);",
        "hint": "Check the spelling of built-in array methods."
      },
      {
        "language": "JavaScript",
        "bugType": "Scope Issue",
        "description": "Variable declared with var in a loop (Lang: JavaScript, Q11)",
        "buggyCode": "for (var k = 0; k < 5; k++) {\n    setTimeout(() => console.log(k), 0);\n}",
        "correctCode": "for (let k = 0; k < 5; k++) {\n    setTimeout(() => console.log(k), 0);\n}",
        "hint": "`var` is function-scoped, `let` is block-scoped."
      },
      {
        "language": "JavaScript",
        "bugType": "Async/Promise Error",
        "description": "Missing catch for promise rejection (Lang: JavaScript, Q12)",
        "buggyCode": "new Promise((resolve, reject) => {\n    reject('Something went wrong!');\n});",
        "correctCode": "new Promise((resolve, reject) => {\n    reject('Something went wrong!');\n}).catch(error => console.error(error));",
        "hint": "Unhandled promise rejections can cause unhandled errors."
      },
      {
        "language": "JavaScript",
        "bugType": "Logic Error",
        "description": "Incorrect logical operator (Lang: JavaScript, Q13)",
        "buggyCode": "function isEvenAndPositive(num) {\n    return num % 2 == 0 || num > 0;\n}",
        "correctCode": "function isEvenAndPositive(num) {\n    return num % 2 === 0 && num > 0;\n}",
        "hint": "Check if both conditions must be true."
      },
      {
        "language": "JavaScript",
        "bugType": "Runtime Error",
        "description": "Using const without initialization (Lang: JavaScript, Q14)",
        "buggyCode": "const PI;\nPI = 3.14;",
        "correctCode": "const PI = 3.14;",
        "hint": "Constants must be initialized when declared."
      },
      {
        "language": "JavaScript",
        "bugType": "Scope Issue",
        "description": "Variable access before declaration (hoisting) (Lang: JavaScript, Q15)",
        "buggyCode": "console.log(myVar);\nvar myVar = 10;",
        "correctCode": "var myVar = 10;\nconsole.log(myVar);",
        "hint": "`var` variables are hoisted but not initialized."
      },
      {
        "language": "JavaScript",
        "bugType": "Async/Promise Error",
        "description": "Async function not returning a promise (Lang: JavaScript, Q16)",
        "buggyCode": "async function fetchData() {\n    return 'Data';\n}",
        "correctCode": "async function fetchData() {\n    return Promise.resolve('Data');\n}",
        "hint": "Async functions implicitly return promises, but explicitly returning one is sometimes needed for complex flows."
      },
      {
        "language": "JavaScript",
        "bugType": "Logic Error",
        "description": "Incorrect comparison for object equality (Lang: JavaScript, Q17)",
        "buggyCode": "let obj1 = {a: 1};\nlet obj2 = {a: 1};\nconsole.log(obj1 == obj2);",
        "correctCode": "let obj1 = {a: 1};\nlet obj2 = {a: 1};\nconsole.log(JSON.stringify(obj1) === JSON.stringify(obj2));",
        "hint": "Objects are compared by reference, not value."
      },
      {
        "language": "JavaScript",
        "bugType": "Runtime Error",
        "description": "Attempting to reassign a const variable (Lang: JavaScript, Q18)",
        "buggyCode": "const count = 5;\ncount = 10;",
        "correctCode": "let count = 5;\ncount = 10;",
        "hint": "Variables declared with `const` cannot be reassigned."
      },
      {
        "language": "JavaScript",
        "bugType": "Scope Issue",
        "description": "Using 'this' incorrectly in a callback (Lang: JavaScript, Q19)",
        "buggyCode": "class MyClass {\n    constructor() {\n        this.value = 10;\n    }\n    logValue() {\n        setTimeout(function() {\n            console.log(this.value);\n        }, 100);\n    }\n}",
        "correctCode": "class MyClass {\n    constructor() {\n        this.value = 10;\n    }\n    logValue() {\n        setTimeout(() => {\n            console.log(this.value);\n        }, 100);\n    }\n}",
        "hint": "Arrow functions bind `this` lexically."
      },
      {
        "language": "JavaScript",
        "bugType": "Async/Promise Error",
        "description": "Missing await in async function (Lang: JavaScript, Q20)",
        "buggyCode": "async function fetchData() {\n    let data = Promise.resolve('Hello');\n    return data;\n}",
        "correctCode": "async function fetchData() {\n    let data = await Promise.resolve('Hello');\n    return data;\n}",
        "hint": "Awaiting a promise unwraps its value."
      }
    ],
    "medium": [
      {
        "language": "JavaScript",
        "bugType": "Scope Issue",
        "description": "Variable declared with var in a loop (Lang: JavaScript, Q1)",
        "buggyCode": "for (var i = 0; i < 3; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000);\n}",
        "correctCode": "for (let i = 0; i < 3; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000);\n}",
        "hint": "Consider block-scoping with variable scoping - use let instead of var."
      },
      {
        "language": "JavaScript",
        "bugType": "Async/Promise Error",
        "description": "Missing await in async function (Lang: JavaScript, Q2)",
        "buggyCode": "async function fetchUserData(userId) {\n    try {\n        let response = fetch(`/api/users/${userId}`);\n        let userData = response.json();\n        return userData.name;\n    } catch (error) {\n        return \"Error loading user\";\n    }\n}",
        "correctCode": "async function fetchUserData(userId) {\n    try {\n        let response = await fetch(`/api/users/${userId}`);\n        let userData = await response.json();\n        return userData.name;\n    } catch (error) {\n        return \"Error loading user\";\n    }\n}",
        "hint": "Fetching data and parsing JSON are asynchronous operations."
      },
      {
        "language": "JavaScript",
        "bugType": "Closure/Context Issue",
        "description": "Incorrect 'this' context in event handler (Lang: JavaScript, Q3)",
        "buggyCode": "class MyButton {\n    constructor(label) {\n        this.label = label;\n        this.element = document.createElement('button');\n        this.element.textContent = label;\n        this.element.addEventListener('click', this.handleClick);\n    }\n    handleClick() {\n        console.log(`Button ${this.label} clicked`);\n    }\n}",
        "correctCode": "class MyButton {\n    constructor(label) {\n        this.label = label;\n        this.element = document.createElement('button');\n        this.element.textContent = label;\n        this.element.addEventListener('click', this.handleClick.bind(this));\n    }\n    handleClick() {\n        console.log(`Button ${this.label} clicked`);\n    }\n}",
        "hint": "The value of `this` inside an event listener might not be what you expect. Bind the method's `this` context."
      },
      {
        "language": "JavaScript",
        "bugType": "Type Coercion",
        "description": "Loose equality (==) causing unexpected results (Lang: JavaScript, Q4)",
        "buggyCode": "if ('0' == false) {\n    console.log('True');\n} else {\n    console.log('False');\n}",
        "correctCode": "if ('0' === false) {\n    console.log('True');\n} else {\n    console.log('False');\n}",
        "hint": "Always prefer strict equality (`===`) to avoid type coercion."
      },
      {
        "language": "JavaScript",
        "bugType": "Prototype Chain",
        "description": "Adding method to Array.prototype incorrectly (Lang: JavaScript, Q5)",
        "buggyCode": "Array.prototype.first = function() {\n    return this[0];\n};\n\nfor (let key in []) {\n    console.log(key);\n}",
        "correctCode": "Object.defineProperty(Array.prototype, 'first', {\n    value: function() { return this[0]; },\n    enumerable: false\n});\n\nfor (let key in []) {\n    console.log(key);\n}",
        "hint": "Avoid adding enumerable properties to built-in prototypes to prevent `for...in` loops from iterating over them."
      },
      {
        "language": "JavaScript",
        "bugType": "Scope Issue",
        "description": "Variable declared with var in a loop (Lang: JavaScript, Q6)",
        "buggyCode": "const items = ['a', 'b', 'c'];\nconst callbacks = [];\nfor (var i = 0; i < items.length; i++) {\n    callbacks.push(function() { console.log(items[i]); });\n}\ncallbacks.forEach(cb => cb());",
        "correctCode": "const items = ['a', 'b', 'c'];\nconst callbacks = [];\nfor (let i = 0; i < items.length; i++) {\n    callbacks.push(function() { console.log(items[i]); });\n}\ncallbacks.forEach(cb => cb());",
        "hint": "The `var` keyword does not create block scope."
      },
      {
        "language": "JavaScript",
        "bugType": "Async/Promise Error",
        "description": "Chaining promises without returning (Lang: JavaScript, Q7)",
        "buggyCode": "function step1() { return Promise.resolve(1); }\nfunction step2(val) { return Promise.resolve(val + 1); }\n\nstep1().then(result => {\n    step2(result);\n}).then(finalResult => {\n    console.log(finalResult); // undefined\n});",
        "correctCode": "function step1() { return Promise.resolve(1); }\nfunction step2(val) { return Promise.resolve(val + 1); }\n\nstep1().then(result => {\n    return step2(result); // Return the promise\n}).then(finalResult => {\n    console.log(finalResult);\n});",
        "hint": "To chain promises, ensure each `.then()` callback returns a promise."
      },
      {
        "language": "JavaScript",
        "bugType": "Closure/Context Issue",
        "description": "Incorrect 'this' context in event handler (Lang: JavaScript, Q8)",
        "buggyCode": "document.getElementById('myBtn').addEventListener('click', function() {\n    console.log(this.id);\n    setTimeout(function() {\n        console.log(this.id); // 'this' is window/undefined here\n    }, 100);\n});",
        "correctCode": "document.getElementById('myBtn').addEventListener('click', function() {\n    const self = this; // Capture 'this'\n    console.log(self.id);\n    setTimeout(function() {\n        console.log(self.id);\n    }, 100);\n});\n// OR using arrow function:\ndocument.getElementById('myBtn').addEventListener('click', function() {\n    console.log(this.id);\n    setTimeout(() => {\n        console.log(this.id);\n    }, 100);\n});",
        "hint": "The context of `this` changes depending on how the function is called. Arrow functions inherit `this` from their lexical scope."
      },
      {
        "language": "JavaScript",
        "bugType": "Type Coercion",
        "description": "Loose equality with numbers and strings (Lang: JavaScript, Q9)",
        "buggyCode": "console.log(10 == '10');",
        "correctCode": "console.log(10 === '10');",
        "hint": "Loose equality (`==`) performs type coercion, which can lead to unexpected results."
      },
      {
        "language": "JavaScript",
        "bugType": "Prototype Chain",
        "description": "Incorrectly extending built-in objects (Lang: JavaScript, Q10)",
        "buggyCode": "String.prototype.reverse = function() {\n    return this.split('').reverse().join('');\n};\n\nlet str = 'hello';\nconsole.log(str.reverse());",
        "correctCode": "// Avoid extending built-in prototypes directly\nfunction reverseString(str) {\n    return str.split('').reverse().join('');\n}\n\nlet str = 'hello';\nconsole.log(reverseString(str));",
        "hint": "Modifying `prototype` of built-in objects can cause conflicts with libraries or future JavaScript versions. If you must, make it non-enumerable."
      },
      {
        "language": "JavaScript",
        "bugType": "Scope Issue",
        "description": "Variable declared with var in a loop (Lang: JavaScript, Q11)",
        "buggyCode": "for (var i = 0; i < 3; i++) {\n    setTimeout(function() {\n        console.log('Value is: ' + i);\n    }, 1000);\n}",
        "correctCode": "for (let i = 0; i < 3; i++) {\n    setTimeout(function() {\n        console.log('Value is: ' + i);\n    }, 1000);\n}",
        "hint": "Use `let` for block-scoped variables in loops to capture the correct value."
      },
      {
        "language": "JavaScript",
        "bugType": "Async/Promise Error",
        "description": "Missing await in async function (Lang: JavaScript, Q12)",
        "buggyCode": "async function processRequest() {\n    let data = fetch('/api/data');\n    let json = data.json();\n    return json;\n}",
        "correctCode": "async function processRequest() {\n    let data = await fetch('/api/data');\n    let json = await data.json();\n    return json;\n}",
        "hint": "Each asynchronous operation returning a Promise needs to be awaited to get its resolved value."
      },
      {
        "language": "JavaScript",
        "bugType": "Closure/Context Issue",
        "description": "Incorrect 'this' context in callback (Lang: JavaScript, Q13)",
        "buggyCode": "const obj = {\n    name: 'Object',\n    greet: function() {\n        setTimeout(function() {\n            console.log(`Hello from ${this.name}`);\n        }, 100);\n    }\n};",
        "correctCode": "const obj = {\n    name: 'Object',\n    greet: function() {\n        setTimeout(() => {\n            console.log(`Hello from ${this.name}`);\n        }, 100);\n    }\n};",
        "hint": "Arrow functions preserve the `this` context of the enclosing lexical scope."
      },
      {
        "language": "JavaScript",
        "bugType": "Type Coercion",
        "description": "Loose equality with null and undefined (Lang: JavaScript, Q14)",
        "buggyCode": "console.log(null == undefined);",
        "correctCode": "console.log(null === undefined);",
        "hint": "`==` treats null and undefined as equal, `===` does not."
      },
      {
        "language": "JavaScript",
        "bugType": "Prototype Chain",
        "description": "Incorrectly using `instanceof` with objects from different realms (Lang: JavaScript, Q15)",
        "buggyCode": "// Assume 'arr' comes from a different iframe/window\nconst arr = [1, 2, 3]; // This would be window.frames[0].Array\nconsole.log(arr instanceof Array);",
        "correctCode": "const arr = [1, 2, 3];\nconsole.log(Object.prototype.toString.call(arr) === '[object Array]');",
        "hint": "`instanceof` may fail when comparing objects from different JavaScript execution contexts (e.g., iframes)."
      },
      {
        "language": "JavaScript",
        "bugType": "Scope Issue",
        "description": "Variable declared with var in a loop (Lang: JavaScript, Q16)",
        "buggyCode": "var functions = [];\nfor (var i = 0; i < 3; i++) {\n    functions.push(function() { return i; });\n}\nconsole.log(functions[0](), functions[1](), functions[2]());",
        "correctCode": "var functions = [];\nfor (let i = 0; i < 3; i++) {\n    functions.push(function() { return i; });\n}\nconsole.log(functions[0](), functions[1](), functions[2]());",
        "hint": "Using `let` instead of `var` creates a new lexical scope for each iteration."
      },
      {
        "language": "JavaScript",
        "bugType": "Async/Promise Error",
        "description": "Not handling promise rejection correctly (Lang: JavaScript, Q17)",
        "buggyCode": "new Promise((resolve, reject) => {\n    reject('Failed to load data');\n});",
        "correctCode": "new Promise((resolve, reject) => {\n    reject('Failed to load data');\n}).catch(error => {\n    console.error('Caught error:', error);\n});",
        "hint": "Always include a `.catch()` block or use `try...catch` with `await` to handle promise rejections."
      },
      {
        "language": "JavaScript",
        "bugType": "Closure/Context Issue",
        "description": "Incorrect 'this' context in `forEach` callback (Lang: JavaScript, Q18)",
        "buggyCode": "const team = {\n    name: 'Warriors',\n    players: ['Curry', 'Thompson'],\n    listPlayers: function() {\n        this.players.forEach(function(player) {\n            console.log(`${this.name}: ${player}`); // 'this.name' will be undefined\n        });\n    }\n};",
        "correctCode": "const team = {\n    name: 'Warriors',\n    players: ['Curry', 'Thompson'],\n    listPlayers: function() {\n        this.players.forEach((player) => {\n            console.log(`${this.name}: ${player}`); // 'this' is lexically bound\n        });\n    }\n};",
        "hint": "Arrow functions capture `this` from their lexical scope, unlike traditional function expressions."
      },
      {
        "language": "JavaScript",
        "bugType": "Type Coercion",
        "description": "Adding string to number (Lang: JavaScript, Q19)",
        "buggyCode": "let result = '5' + 5;\nconsole.log(result);",
        "correctCode": "let result = parseInt('5') + 5;\nconsole.log(result);",
        "hint": "The `+` operator can concatenate strings or add numbers. Type coercion applies here."
      },
      {
        "language": "JavaScript",
        "bugType": "Prototype Chain",
        "description": "Incorrectly checking for own property (Lang: JavaScript, Q20)",
        "buggyCode": "const obj = { a: 1, b: 2 };\nfor (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n        console.log(key);\n    }\n}",
        "correctCode": "const obj = { a: 1, b: 2 };\nfor (let key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        console.log(key);\n    }\n}",
        "hint": "It's safer to use `Object.prototype.hasOwnProperty.call()` when dealing with objects that might override `hasOwnProperty`."
      }
    ],
    "hard": [
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Incorrect order of async operations in event loop (Lang: JavaScript, Q1)",
        "buggyCode": "console.log('Start');\n\nsetTimeout(() => console.log('Timeout'), 0);\n\nPromise.resolve().then(() => console.log('Promise'));\n\nconsole.log('End');",
        "correctCode": "console.log('Start');\n\nPromise.resolve().then(() => console.log('Promise'));\n\nsetTimeout(() => console.log('Timeout'), 0);\n\nconsole.log('End');",
        "hint": "Microtasks (Promises) are executed before macrotasks (setTimeout) in the event loop."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Retained closure in long-lived event handler (Lang: JavaScript, Q2)",
        "buggyCode": "function setupButton() {\n    let largeArray = new Array(1000000).fill(0); // Large data\n    const button = document.getElementById('myBtn');\n    button.addEventListener('click', function handler() {\n        console.log('Button clicked');\n        // 'largeArray' is captured by this closure\n    });\n    // If button is never removed, largeArray is never garbage collected\n}",
        "correctCode": "function setupButton() {\n    let largeArray = null; // Don't create if not needed in handler\n    const button = document.getElementById('myBtn');\n    const handler = () => {\n        // If largeArray is truly needed, handle its lifecycle or pass relevant data\n        console.log('Button clicked');\n    };\n    button.addEventListener('click', handler);\n    // To prevent leak, remove handler when button is no longer needed:\n    // button.removeEventListener('click', handler);\n    // Or avoid capturing large variables in long-lived closures.\n}",
        "hint": "Closures retain references to their outer scope variables. Long-lived closures can lead to memory leaks if they capture large objects."
      },
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Incorrect order of async operations (Lang: JavaScript, Q3)",
        "buggyCode": "console.log('A');\nqueueMicrotask(() => console.log('B'));\nsetTimeout(() => console.log('C'), 0);\nPromise.resolve().then(() => console.log('D'));\nconsole.log('E');",
        "correctCode": "console.log('A');\nconsole.log('E');\nPromise.resolve().then(() => console.log('D'));\nqueueMicrotask(() => console.log('B'));\nsetTimeout(() => console.log('C'), 0);",
        "hint": "Understand the microtask queue (Promise.then, queueMicrotask) vs macrotask queue (setTimeout, DOM events)."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Detached DOM nodes (Lang: JavaScript, Q4)",
        "buggyCode": "let element = document.createElement('div');\nlet reference = element;\ndocument.body.appendChild(element);\n// Assume element is later removed from DOM, but 'reference' still holds it\nelement.remove();",
        "correctCode": "let element = document.createElement('div');\ndocument.body.appendChild(element);\n// Ensure all references are nulled out if element is removed and not needed\nelement.remove();\nelement = null; // Explicitly nullify reference if not needed\n// reference = null; // Also nullify other references\n",
        "hint": "If a DOM element is removed from the DOM but still referenced by JavaScript, it won't be garbage collected."
      },
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Mixing synchronous and asynchronous array iteration (Lang: JavaScript, Q5)",
        "buggyCode": "const items = [1, 2, 3];\nitems.forEach(async (item) => {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    console.log(item);\n});\nconsole.log('All items processed');",
        "correctCode": "async function processAllItems() {\n    const items = [1, 2, 3];\n    for (const item of items) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        console.log(item);\n    }\n    console.log('All items processed');\n}\nprocessAllItems();",
        "hint": "forEach is synchronous and doesn't wait for async callbacks. Use `for...of` loop with `await` for sequential async operations."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Circular references in JavaScript objects (Lang: JavaScript, Q6)",
        "buggyCode": "function createCircularRef() {\n    const obj1 = {};\n    const obj2 = {};\n    obj1.ref = obj2;\n    obj2.ref = obj1;\n    return obj1;\n}\n\nlet leak = createCircularRef();\nleak = null; // Still might not be collected depending on JS engine",
        "correctCode": "function createCircularRef() {\n    const obj1 = {};\n    const obj2 = {};\n    obj1.ref = obj2;\n    // No circular ref, or carefully manage it if necessary\n    // obj2.ref = obj1;\n    return obj1;\n}\n\nlet noLeak = createCircularRef();\nnoLeak = null; // Will be collected",
        "hint": "Modern garbage collectors handle circular references, but be mindful in older environments or complex scenarios, especially with DOM."
      },
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Incorrect order of async operations in event loop (Lang: JavaScript, Q7)",
        "buggyCode": "console.log('Start');\nPromise.resolve().then(() => console.log('Promise 1'));\nsetImmediate(() => console.log('Immediate')); // Node.js specific\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise 2'));\nconsole.log('End');",
        "correctCode": "console.log('Start');\nconsole.log('End');\nPromise.resolve().then(() => console.log('Promise 1'));\nPromise.resolve().then(() => console.log('Promise 2'));\n// In Node.js: process.nextTick > Promises > setImmediate > setTimeout\n// In browser: Microtasks (Promises, queueMicrotask) > Macrotasks (setTimeout)\n// Assuming browser context for setTimeout vs Promise:\nsetTimeout(() => console.log('Timeout'), 0);",
        "hint": "Understand the event loop queues: Microtask Queue (Promises) vs Macrotask Queue (setTimeout, setImmediate in Node.js)."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Detached event listeners (Lang: JavaScript, Q8)",
        "buggyCode": "let button = document.createElement('button');\ndocument.body.appendChild(button);\nbutton.addEventListener('click', function handler() {\n    // This handler will keep 'button' in memory even if removed from DOM\n    console.log('Clicked');\n});\nbutton.remove(); // Button element removed, but handler still referenced",
        "correctCode": "let button = document.createElement('button');\ndocument.body.appendChild(button);\nconst handler = function() {\n    console.log('Clicked');\n};\nbutton.addEventListener('click', handler);\nbutton.removeEventListener('click', handler); // Explicitly remove listener\nbutton.remove();",
        "hint": "Always remove event listeners when the element or handler is no longer needed, especially for long-lived elements or closures."
      },
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Incorrect order of async operations in event loop (Lang: JavaScript, Q9)",
        "buggyCode": "const p = Promise.resolve();\n\n(async () => {\n  await p;\n  console.log('after await');\n})();\n\np.then(() => console.log('then'));\n\nconsole.log('sync');",
        "correctCode": "console.log('sync');\nconst p = Promise.resolve();\n\np.then(() => console.log('then'));\n\n(async () => {\n  await p;\n  console.log('after await');\n})();",
        "hint": "`await` internally suspends the async function, allowing other microtasks (like `.then()`) on the same promise to run first."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Global variables retaining references (Lang: JavaScript, Q10)",
        "buggyCode": "function createLargeObject() {\n    window.largeObject = new Array(1000000).fill('data');\n}\ncreateLargeObject();\n// largeObject remains in memory until page close or explicit nulling",
        "correctCode": "function createLargeObject() {\n    const tempObject = new Array(1000000).fill('data');\n    // Use tempObject for its purpose, then let it go out of scope\n    // Avoid assigning to global scope (window) if not strictly necessary\n}\ncreateLargeObject();\n// If a global reference is needed, ensure it's explicitly nulled when done\n// window.largeObject = null;",
        "hint": "Global variables are root references and prevent garbage collection. Avoid them unless necessary, or explicitly nullify them."
      },
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Incorrect order of async operations in event loop (Lang: JavaScript, Q11)",
        "buggyCode": "console.log('First');\nsetTimeout(() => console.log('Second'), 0);\nPromise.resolve().then(() => console.log('Third'));\nconsole.log('Fourth');",
        "correctCode": "console.log('First');\nconsole.log('Fourth');\nPromise.resolve().then(() => console.log('Third'));\nsetTimeout(() => console.log('Second'), 0);",
        "hint": "Microtasks run before macrotasks after the current call stack clears."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Retained closure in long-lived event handler (Lang: JavaScript, Q12)",
        "buggyCode": "function setupExpensiveTask() {\n    let heavyData = { /* very large object */ };\n    document.getElementById('execBtn').addEventListener('click', function() {\n        // heavyData is captured here\n        console.log('Executing task');\n    });\n}",
        "correctCode": "function setupExpensiveTask() {\n    // If heavyData is not directly used in the handler or only needed temporarily\n    // Consider passing only necessary parts or creating it on demand.\n    const execBtn = document.getElementById('execBtn');\n    const handler = () => {\n        console.log('Executing task');\n        // heavyData = null; if it was local to handler and temporary\n    };\n    execBtn.addEventListener('click', handler);\n    // To prevent leak if element is removed from DOM:\n    // execBtn.removeEventListener('click', handler);\n}",
        "hint": "Be cautious with large objects captured by closures, especially in repeatedly called functions or long-lived event listeners."
      },
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Incorrect order of async operations (Lang: JavaScript, Q13)",
        "buggyCode": "async function main() {\n    console.log(1);\n    await Promise.resolve();\n    console.log(2);\n}\nmain();\nconsole.log(3);\nPromise.resolve().then(() => console.log(4));",
        "correctCode": "async function main() {\n    console.log(1);\n    await Promise.resolve();\n    console.log(2);\n}\nconsole.log(3);\nPromise.resolve().then(() => console.log(4));\nmain();",
        "hint": "The `await` keyword effectively yields control back to the event loop, allowing other synchronous and microtask code to run."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Detached DOM nodes (Lang: JavaScript, Q14)",
        "buggyCode": "let container = document.getElementById('container');\nfor(let i=0; i<1000; i++) {\n    let div = document.createElement('div');\n    div.id = 'div-' + i;\n    container.appendChild(div);\n}\n// Later, if container is cleared, but references to divs persist\ncontainer.innerHTML = '';",
        "correctCode": "let container = document.getElementById('container');\nfor(let i=0; i<1000; i++) {\n    let div = document.createElement('div');\n    div.id = 'div-' + i;\n    container.appendChild(div);\n}\n// Clear references explicitly if needed, or manage component lifecycle\ncontainer.innerHTML = '';\n// If individual 'div' references were stored in an array, clear that too.\n",
        "hint": "When removing elements from the DOM, ensure no JavaScript references to them (or their descendants) remain if you want them garbage collected."
      },
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Mixing synchronous and asynchronous array iteration (Lang: JavaScript, Q15)",
        "buggyCode": "const numbers = [1, 2, 3];\nnumbers.map(async (num) => {\n    await new Promise(res => setTimeout(res, 50));\n    return num * 2;\n}).then(results => console.log(results));",
        "correctCode": "async function processNumbers() {\n    const numbers = [1, 2, 3];\n    const promises = numbers.map(async (num) => {\n        await new Promise(res => setTimeout(res, 50));\n        return num * 2;\n    });\n    const results = await Promise.all(promises);\n    console.log(results);\n}\nprocessNumbers();",
        "hint": "`.map()` with `async` callbacks returns an array of Promises, not resolved values directly. Use `Promise.all()` to wait for all."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Circular references in JavaScript objects (Lang: JavaScript, Q16)",
        "buggyCode": "function createObjectPair() {\n    const objA = {};\n    const objB = {};\n    objA.buddy = objB;\n    objB.partner = objA;\n    return objA;\n}\n\nlet pair = createObjectPair();\npair = null;",
        "correctCode": "function createObjectPair() {\n    const objA = {};\n    const objB = {};\n    objA.buddy = objB;\n    // objB.partner = objA; // Remove the direct circular reference\n    return objA;\n}\n\nlet pair = createObjectPair();\npair = null;",
        "hint": "Break explicit circular references in complex object graphs if not strictly needed for functionality."
      },
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Incorrect order of async operations (Lang: JavaScript, Q17)",
        "buggyCode": "setTimeout(() => console.log('A'), 10);\nPromise.resolve().then(() => console.log('B'));\nconsole.log('C');",
        "correctCode": "console.log('C');\nPromise.resolve().then(() => console.log('B'));\nsetTimeout(() => console.log('A'), 10);",
        "hint": "Synchronous code runs first, then microtasks, then macrotasks."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Retained closure in long-lived event handler (Lang: JavaScript, Q18)",
        "buggyCode": "let cache = {};\ndocument.getElementById('dataButton').addEventListener('click', function() {\n    // 'cache' is captured by this closure, preventing its GC even if not used actively\n    if (!cache.data) {\n        cache.data = Array(100000).fill(Math.random());\n    }\n    console.log('Data loaded');\n});",
        "correctCode": "let cache = {};\nconst dataButton = document.getElementById('dataButton');\nconst handler = function() {\n    if (!cache.data) {\n        cache.data = Array(100000).fill(Math.random());\n    }\n    console.log('Data loaded');\n};\ndataButton.addEventListener('click', handler);\n// When dataButton is no longer needed:\n// dataButton.removeEventListener('click', handler);\n// cache = {}; // If the cache itself should be cleared\n",
        "hint": "Be mindful of variables captured by closures used in event listeners that live for the page's lifetime."
      },
      {
        "language": "JavaScript",
        "bugType": "Event Loop/Concurrency",
        "description": "Incorrect order of async operations in event loop (Lang: JavaScript, Q19)",
        "buggyCode": "async function test() {\n    console.log('Inside async');\n    await Promise.resolve();\n    console.log('After await');\n}\nconsole.log('Before async');\ntest();\nconsole.log('After calling async');",
        "correctCode": "console.log('Before async');\nconsole.log('Inside async');\nconsole.log('After calling async');\nconsole.log('After await');",
        "hint": "The `await` keyword pauses execution, but the rest of the current function's synchronous code continues."
      },
      {
        "language": "JavaScript",
        "bugType": "Memory Leak",
        "description": "Detached DOM nodes (Lang: JavaScript, Q20)",
        "buggyCode": "let list = document.getElementById('myList');\nfor(let i=0; i<5; i++) {\n    let item = document.createElement('li');\n    item.textContent = `Item ${i}`;\n    list.appendChild(item);\n}\n// Assume references to `item` are stored somewhere, but list.innerHTML is cleared\nlist.innerHTML = '';",
        "correctCode": "let list = document.getElementById('myList');\nconst items = [];\nfor(let i=0; i<5; i++) {\n    let item = document.createElement('li');\n    item.textContent = `Item ${i}`;\n    list.appendChild(item);\n    items.push(item); // Store refs if needed\n}\n\nlist.innerHTML = '';\n// If references were stored and are no longer needed:\n// items.length = 0; // Clear array\n",
        "hint": "Clearing `innerHTML` removes DOM nodes but doesn't necessarily free up memory if JavaScript still holds references to those nodes."
      }
    ]
  },
  "Java": {
    "easy": [
      {
        "language": "Java",
        "bugType": "Syntax Error",
        "description": "Missing semicolon at the end of a statement (Lang: Java, Q1)",
        "buggyCode": "public class MyClass {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\")\n    }\n}",
        "correctCode": "public class MyClass {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}",
        "hint": "Java statements usually end with a semicolon."
      },
      {
        "language": "Java",
        "bugType": "Logic Error",
        "description": "Incorrect loop condition (Lang: Java, Q2)",
        "buggyCode": "for (int i = 0; i < 5; i++) {\n    if (i == 5) {\n        System.out.println(\"Found 5\");\n    }\n}",
        "correctCode": "for (int i = 0; i < 5; i++) {\n    if (i == 4) { // Or change loop condition\n        System.out.println(\"Found 4\");\n    }\n}",
        "hint": "Check the loop's upper bound and the condition inside the loop."
      },
      {
        "language": "Java",
        "bugType": "Type Mismatch",
        "description": "Assigning incompatible types (Lang: Java, Q3)",
        "buggyCode": "int number = \"5\";",
        "correctCode": "int number = 5;",
        "hint": "Cannot convert String to int directly."
      },
      {
        "language": "Java",
        "bugType": "NullPointerException",
        "description": "Dereferencing a null object (Lang: Java, Q4)",
        "buggyCode": "String str = null;\nSystem.out.println(str.length());",
        "correctCode": "String str = \"hello\";\nSystem.out.println(str.length());",
        "hint": "Always check for null before using object methods."
      },
      {
        "language": "Java",
        "bugType": "ArrayIndexOutOfBoundsException",
        "description": "Accessing array out of bounds (Lang: Java, Q5)",
        "buggyCode": "int[] arr = {1, 2, 3};\nSystem.out.println(arr[3]);",
        "correctCode": "int[] arr = {1, 2, 3};\nSystem.out.println(arr[2]); // Access last element correctly",
        "hint": "Array indices are 0-based. The last index is `length - 1`."
      },
      {
        "language": "Java",
        "bugType": "Syntax Error",
        "description": "Missing curly brace (Lang: Java, Q6)",
        "buggyCode": "public class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Hello\");\n}",
        "correctCode": "public class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Hello\");\n    }\n}",
        "hint": "Ensure all blocks are properly opened and closed."
      },
      {
        "language": "Java",
        "bugType": "Logic Error",
        "description": "Incorrect boolean comparison (Lang: Java, Q7)",
        "buggyCode": "boolean isValid = false;\nif (isValid = true) { // Assignment instead of comparison\n    System.out.println(\"Valid\");\n}",
        "correctCode": "boolean isValid = false;\nif (isValid == true) { // Correct comparison\n    System.out.println(\"Valid\");\n}",
        "hint": "Use `==` for comparison, not `=` for assignment in conditions."
      },
      {
        "language": "Java",
        "bugType": "Type Mismatch",
        "description": "Implicit conversion from float to int (Lang: Java, Q8)",
        "buggyCode": "int x = 5.5f;",
        "correctCode": "int x = (int) 5.5f; // Explicit cast\n// Or: float x = 5.5f;",
        "hint": "Java does not allow implicit narrowing conversions."
      },
      {
        "language": "Java",
        "bugType": "NullPointerException",
        "description": "Dereferencing a null object (Lang: Java, Q9)",
        "buggyCode": "List<String> names = null;\nSystem.out.println(names.size());",
        "correctCode": "List<String> names = new ArrayList<>();\nSystem.out.println(names.size());",
        "hint": "Initialize collections before use."
      },
      {
        "language": "Java",
        "bugType": "ArrayIndexOutOfBoundsException",
        "description": "Accessing array out of bounds (Lang: Java, Q10)",
        "buggyCode": "String[] colors = {\"red\", \"green\"};\nSystem.out.println(colors[2]);",
        "correctCode": "String[] colors = {\"red\", \"green\"};\nSystem.out.println(colors[1]);",
        "hint": "The largest valid index is `array.length - 1`."
      },
      {
        "language": "Java",
        "bugType": "Syntax Error",
        "description": "Missing import statement (Lang: Java, Q11)",
        "buggyCode": "public class Main {\n    public static void main(String[] args) {\n        ArrayList<String> list = new ArrayList<>();\n    }\n}",
        "correctCode": "import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList<String> list = new ArrayList<>();\n    }\n}",
        "hint": "Classes like `ArrayList` need to be imported from their packages."
      },
      {
        "language": "Java",
        "bugType": "Logic Error",
        "description": "Integer division losing precision (Lang: Java, Q12)",
        "buggyCode": "int a = 5;\nint b = 2;\ndouble result = a / b;\nSystem.out.println(result);",
        "correctCode": "int a = 5;\nint b = 2;\ndouble result = (double) a / b;\nSystem.out.println(result);",
        "hint": "Integer division truncates decimals. Cast one operand to double/float."
      },
      {
        "language": "Java",
        "bugType": "Type Mismatch",
        "description": "Using wrong wrapper class for primitive (Lang: Java, Q13)",
        "buggyCode": "Integer i = 10;\nLong l = i;",
        "correctCode": "Integer i = 10;\nLong l = Long.valueOf(i.longValue()); // Explicit conversion\n// Or: long lPrim = i.longValue();",
        "hint": "Autoboxing/unboxing works for direct primitive-to-wrapper, but not between different wrapper types directly."
      },
      {
        "language": "Java",
        "bugType": "NullPointerException",
        "description": "Dereferencing a null object (Lang: Java, Q14)",
        "buggyCode": "Map<String, String> map = null;\nmap.put(\"key\", \"value\");",
        "correctCode": "Map<String, String> map = new HashMap<>();\nmap.put(\"key\", \"value\");",
        "hint": "Uninitialized map will be null."
      },
      {
        "language": "Java",
        "bugType": "ArrayIndexOutOfBoundsException",
        "description": "Off-by-one error in loop (Lang: Java, Q15)",
        "buggyCode": "int[] numbers = {10, 20, 30};\nfor (int i = 0; i <= numbers.length; i++) {\n    System.out.println(numbers[i]);\n}",
        "correctCode": "int[] numbers = {10, 20, 30};\nfor (int i = 0; i < numbers.length; i++) {\n    System.out.println(numbers[i]);\n}",
        "hint": "Loop condition `i <= length` allows access to an invalid index."
      },
      {
        "language": "Java",
        "bugType": "Syntax Error",
        "description": "Missing 'static' keyword for main method (Lang: Java, Q16)",
        "buggyCode": "public class MyProgram {\n    public void main(String[] args) {\n        System.out.println(\"Hello\");\n    }\n}",
        "correctCode": "public class MyProgram {\n    public static void main(String[] args) {\n        System.out.println(\"Hello\");\n    }\n}",
        "hint": "The `main` method must be static to be callable without an object."
      },
      {
        "language": "Java",
        "bugType": "Logic Error",
        "description": "Incorrect string comparison (Lang: Java, Q17)",
        "buggyCode": "String s1 = new String(\"hello\");\nString s2 = new String(\"hello\");\nif (s1 == s2) {\n    System.out.println(\"Strings are equal\");\n}",
        "correctCode": "String s1 = new String(\"hello\");\nString s2 = new String(\"hello\");\nif (s1.equals(s2)) {\n    System.out.println(\"Strings are equal\");\n}",
        "hint": "In Java, `==` compares object references, use `equals()` for content comparison."
      },
      {
        "language": "Java",
        "bugType": "Type Mismatch",
        "description": "Trying to cast incompatible types (Lang: Java, Q18)",
        "buggyCode": "Object o = \"string\";\nInteger i = (Integer) o;",
        "correctCode": "Object o = \"string\";\nString s = (String) o;",
        "hint": "A `ClassCastException` occurs when trying to cast an object to an unrelated type."
      },
      {
        "language": "Java",
        "bugType": "NullPointerException",
        "description": "Dereferencing a null object (Lang: Java, Q19)",
        "buggyCode": "Student student = null;\nSystem.out.println(student.getName());",
        "correctCode": "class Student {\n    String name = \"John\";\n    String getName() { return name; }\n}\nStudent student = new Student();\nSystem.out.println(student.getName());",
        "hint": "An object must be instantiated (not null) before its methods can be called."
      },
      {
        "language": "Java",
        "bugType": "ArrayIndexOutOfBoundsException",
        "description": "Accessing array out of bounds (Lang: Java, Q20)",
        "buggyCode": "int[] data = {5, 10};\nSystem.out.println(data[2]);",
        "correctCode": "int[] data = {5, 10};\nSystem.out.println(data[1]);",
        "hint": "The maximum index for an array of size N is N-1."
      }
    ],
    "medium": [
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Race condition with non-atomic increment (Lang: Java, Q1)",
        "buggyCode": "class Counter {\n    public int count = 0;\n    public void increment() {\n        count++;\n    }\n}\n\n// Simulate with threads (example code, actual threading logic omitted for brevity)\n// Thread 1: counter.increment();\n// Thread 2: counter.increment();",
        "correctCode": "import java.util.concurrent.atomic.AtomicInteger;\n\nclass Counter {\n    public AtomicInteger count = new AtomicInteger(0);\n    public void increment() {\n        count.incrementAndGet();\n    }\n}\n\n// Or using synchronized:\n// class Counter {\n//     public int count = 0;\n//     public synchronized void increment() {\n//         count++;\n//     }\n// }",
        "hint": "Incrementing `count++` is not an atomic operation. Use `synchronized` or `AtomicInteger` for thread safety."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Static collection holding object references (Lang: Java, Q2)",
        "buggyCode": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class LeakExample {\n    private static final List<Object> leakList = new ArrayList<>();\n\n    public void addObject(Object obj) {\n        leakList.add(obj);\n    }\n\n    // Objects added here might not be GC'd if they are never removed\n}",
        "correctCode": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class LeakExample {\n    // Ensure objects are removed from static lists when no longer needed.\n    // Or use WeakHashMap/WeakReference if appropriate for caching scenarios.\n    private static final List<Object> leakList = new ArrayList<>();\n\n    public void addAndRemoveObject(Object obj) {\n        leakList.add(obj);\n        // ... later when obj is no longer needed ...\n        leakList.remove(obj);\n    }\n}",
        "hint": "Static collections have a lifetime equal to the application. Objects added to them are not garbage collected until removed."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Deadlock with two locks (Lang: Java, Q3)",
        "buggyCode": "public class DeadlockExample {\n    private Object lock1 = new Object();\n    private Object lock2 = new Object();\n\n    public void method1() {\n        synchronized (lock1) {\n            System.out.println(\"Method 1 holding lock1\");\n            try { Thread.sleep(10); } catch (InterruptedException e) {}\n            synchronized (lock2) {\n                System.out.println(\"Method 1 holding lock1 and lock2\");\n            }\n        }\n    }\n\n    public void method2() {\n        synchronized (lock2) { // Reverse order\n            System.out.println(\"Method 2 holding lock2\");\n            try { Thread.sleep(10); } catch (InterruptedException e) {}\n            synchronized (lock1) {\n                System.out.println(\"Method 2 holding lock2 and lock1\");\n            }\n        }\n    }\n}",
        "correctCode": "public class DeadlockExample {\n    private Object lock1 = new Object();\n    private Object lock2 = new Object();\n\n    // Consistent locking order to prevent deadlock\n    public void method1() {\n        synchronized (lock1) {\n            System.out.println(\"Method 1 holding lock1\");\n            try { Thread.sleep(10); } catch (InterruptedException e) {}\n            synchronized (lock2) {\n                System.out.println(\"Method 1 holding lock1 and lock2\");\n            }\n        }\n    }\n\n    public void method2() {\n        synchronized (lock1) { // Same order as method1\n            System.out.println(\"Method 2 holding lock1\");\n            try { Thread.sleep(10); } catch (InterruptedException e) {}\n            synchronized (lock2) {\n                System.out.println(\"Method 2 holding lock1 and lock2\");\n            }\n        }\n    }\n}",
        "hint": "Deadlock often occurs when threads acquire multiple locks in different orders. Ensure a consistent locking order."
      },
      {
        "language": "Java",
        "bugType": "Resource Leak",
        "description": "Not closing I/O stream (Lang: Java, Q4)",
        "buggyCode": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ReadFile {\n    public void readFileContent(String fileName) throws IOException {\n        BufferedReader reader = new BufferedReader(new FileReader(fileName));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n        // reader.close(); is missing\n    }\n}",
        "correctCode": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ReadFile {\n    public void readFileContent(String fileName) throws IOException {\n        // Use try-with-resources to ensure resource closure\n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        }\n    }\n}",
        "hint": "Always close I/O resources (streams, connections) to prevent resource leaks. Use try-with-resources for automatic closing."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Non-volatile field used in multithreading (Lang: Java, Q5)",
        "buggyCode": "class Flag {\n    boolean running = true;\n    public void stop() {\n        running = false;\n    }\n    public void runLoop() {\n        while(running) {\n            // do work\n        }\n        System.out.println(\"Loop stopped.\");\n    }\n}",
        "correctCode": "class Flag {\n    volatile boolean running = true; // Use volatile\n    public void stop() {\n        running = false;\n    }\n    public void runLoop() {\n        while(running) {\n            // do work\n        }\n        System.out.println(\"Loop stopped.\");\n    }\n}",
        "hint": "`volatile` ensures visibility of changes across threads by preventing compiler optimizations and ensuring main memory writes."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Static collection holding object references (Lang: Java, Q6)",
        "buggyCode": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Cache {\n    private static final Map<String, Object> dataCache = new HashMap<>();\n\n    public static void putData(String key, Object value) {\n        dataCache.put(key, value);\n    }\n\n    // Objects put into the cache without removal can lead to leaks.\n}",
        "correctCode": "import java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class Cache {\n    // Use WeakHashMap if values should be GC'd when only referenced by the cache\n    private static final Map<String, Object> dataCache = new WeakHashMap<>();\n\n    public static void putData(String key, Object value) {\n        dataCache.put(key, value);\n    }\n\n    public static void removeData(String key) {\n        dataCache.remove(key);\n    }\n}",
        "hint": "If a static map is used as a cache, objects will not be garbage collected until removed or if using `WeakHashMap`."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Deadlock with two locks (Lang: Java, Q7)",
        "buggyCode": "public class PhilosopherProblem {\n    Object leftFork = new Object();\n    Object rightFork = new Object();\n\n    public void eatLeftThenRight() {\n        synchronized (leftFork) {\n            synchronized (rightFork) {\n                // Eating\n            }\n        }\n    }\n\n    public void eatRightThenLeft() {\n        synchronized (rightFork) {\n            synchronized (leftFork) {\n                // Eating\n            }\n        }\n    }\n}",
        "correctCode": "public class PhilosopherProblem {\n    Object fork1 = new Object();\n    Object fork2 = new Object();\n\n    // Standardize the order of acquiring locks\n    public void eatFirstThenSecond() {\n        synchronized (fork1) {\n            synchronized (fork2) {\n                // Eating\n            }\n        }\n    }\n\n    public void eatSecondThenFirst() {\n        synchronized (fork1) { // Always try for fork1 first\n            synchronized (fork2) { // Then fork2\n                // Eating\n            }\n        }\n    }\n}",
        "hint": "A common cause of deadlock is inconsistent lock acquisition order among competing threads."
      },
      {
        "language": "Java",
        "bugType": "Resource Leak",
        "description": "Not closing database connection (Lang: Java, Q8)",
        "buggyCode": "import java.sql.*;\n\npublic class DBUtils {\n    public ResultSet executeQuery(String query) throws SQLException {\n        Connection conn = DriverManager.getConnection(\"jdbc:url\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(query);\n        // conn, stmt, rs are not closed\n        return rs;\n    }\n}",
        "correctCode": "import java.sql.*;\n\npublic class DBUtils {\n    public ResultSet executeQuery(String query) throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        ResultSet rs = null;\n        try {\n            conn = DriverManager.getConnection(\"jdbc:url\");\n            stmt = conn.createStatement();\n            rs = stmt.executeQuery(query);\n            return rs;\n        } finally {\n            // Close resources in reverse order of creation\n            if (rs != null) try { rs.close(); } catch (SQLException e) { /* log error */ }\n            if (stmt != null) try { stmt.close(); } catch (SQLException e) { /* log error */ }\n            if (conn != null) try { conn.close(); } catch (SQLException e) { /* log error */ }\n        }\n    }\n}",
        "hint": "Database connections, statements, and result sets are precious resources and must always be closed."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Non-volatile field used in multithreading (Lang: Java, Q9)",
        "buggyCode": "class Stopper {\n    boolean shouldStop = false;\n\n    public void stopNow() {\n        shouldStop = true;\n    }\n\n    public boolean isStopped() {\n        return shouldStop;\n    }\n\n    // Thread 1 calls stopNow(), Thread 2 calls isStopped() in a loop\n}",
        "correctCode": "class Stopper {\n    volatile boolean shouldStop = false;\n\n    public void stopNow() {\n        shouldStop = true;\n    }\n\n    public boolean isStopped() {\n        return shouldStop;\n    }\n}",
        "hint": "Without `volatile`, a thread might cache the value of `shouldStop` and never see the update from another thread."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Incorrect use of `ThreadLocal` leading to leaks (Lang: Java, Q10)",
        "buggyCode": "import java.lang.ThreadLocal;\n\npublic class ThreadLocalLeak {\n    private static final ThreadLocal<LargeObject> threadLocalData = new ThreadLocal<>();\n\n    public void setAndUseData(LargeObject data) {\n        threadLocalData.set(data);\n        // ... use data ...\n        // No call to threadLocalData.remove() for long-lived threads (e.g., in thread pools)\n    }\n}",
        "correctCode": "import java.lang.ThreadLocal;\n\npublic class ThreadLocalLeak {\n    private static final ThreadLocal<LargeObject> threadLocalData = new ThreadLocal<>();\n\n    public void setAndUseData(LargeObject data) {\n        threadLocalData.set(data);\n        try {\n            // ... use data ...\n        } finally {\n            threadLocalData.remove(); // Always remove data when done\n        }\n    }\n}",
        "hint": "ThreadLocal variables should always be explicitly removed (cleared) when no longer needed, especially in thread-pooled environments."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Race condition with non-atomic increment (Lang: Java, Q11)",
        "buggyCode": "class Counter {\n    public int count = 0;\n    public void increment() {\n        count++;\n    }\n}",
        "correctCode": "import java.util.concurrent.atomic.AtomicInteger;\n\nclass Counter {\n    public AtomicInteger count = new AtomicInteger(0);\n    public void increment() {\n        count.incrementAndGet();\n    }\n}",
        "hint": "Incrementing `count++` is not an atomic operation. Use `synchronized` or `AtomicInteger` for thread safety."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Static collection holding object references (Lang: Java, Q12)",
        "buggyCode": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class LeakExample {\n    private static final List<Object> leakList = new ArrayList<>();\n\n    public void addFirstElement(Object obj) {\n        leakList.add(obj);\n    }\n}",
        "correctCode": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class LeakExample {\n    private static final List<Object> leakList = new ArrayList<>();\n\n    public void addAndRemoveObject(Object obj) {\n        leakList.add(obj);\n        // If not using WeakHashMap, ensure explicit removal:\n        // leakList.remove(obj);\n    }\n}",
        "hint": "Static collections retain references, preventing garbage collection unless items are removed."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Deadlock with two locks (Lang: Java, Q13)",
        "buggyCode": "public class DeadlockExample {\n    private Object lockA = new Object();\n    private Object lockB = new Object();\n\n    public void performTask1() {\n        synchronized (lockA) {\n            synchronized (lockB) {\n                // ...\n            }\n        }\n    }\n\n    public void performTask2() {\n        synchronized (lockB) {\n            synchronized (lockA) {\n                // ...\n            }\n        }\n    }\n}",
        "correctCode": "public class DeadlockExample {\n    private Object lockA = new Object();\n    private Object lockB = new Object();\n\n    // Standardize lock acquisition order for all tasks\n    public void performTask1() {\n        synchronized (lockA) {\n            synchronized (lockB) {\n                // ...\n            }\n        }\n    }\n\n    public void performTask2() {\n        synchronized (lockA) { // Acquire lockA first\n            synchronized (lockB) { // Then lockB\n                // ...\n            }\n        }\n    }\n}",
        "hint": "Inconsistent lock ordering is a primary cause of deadlocks in multi-threaded applications."
      },
      {
        "language": "Java",
        "bugType": "Resource Leak",
        "description": "Not closing I/O stream (Lang: Java, Q14)",
        "buggyCode": "import java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileProcessor {\n    public void processFile(String path) throws IOException {\n        FileInputStream fis = new FileInputStream(path);\n        int data;\n        while ((data = fis.read()) != -1) {\n            // process data\n        }\n        // fis.close() is missing\n    }\n}",
        "correctCode": "import java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileProcessor {\n    public void processFile(String path) throws IOException {\n        try (FileInputStream fis = new FileInputStream(path)) {\n            int data;\n            while ((data = fis.read()) != -1) {\n                // process data\n            }\n        }\n    }\n}",
        "hint": "Use try-with-resources to automatically close `AutoCloseable` resources."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Non-volatile field used in multithreading (Lang: Java, Q15)",
        "buggyCode": "class StateHolder {\n    private boolean state = false;\n\n    public void setState(boolean newState) {\n        this.state = newState;\n    }\n\n    public boolean getState() {\n        return this.state;\n    }\n}",
        "correctCode": "class StateHolder {\n    private volatile boolean state = false;\n\n    public void setState(boolean newState) {\n        this.state = newState;\n    }\n\n    public boolean getState() {\n        return this.state;\n    }\n}",
        "hint": "When multiple threads access and modify a shared variable, `volatile` ensures visibility of changes."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Static collection holding object references (Lang: Java, Q16)",
        "buggyCode": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class EventQueue {\n    private static final Queue<Runnable> eventQueue = new LinkedList<>();\n\n    public static void addEvent(Runnable event) {\n        eventQueue.add(event);\n    }\n\n    // Events added might not be removed, leading to memory issues.\n}",
        "correctCode": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class EventQueue {\n    private static final Queue<Runnable> eventQueue = new LinkedList<>();\n\n    public static void addEvent(Runnable event) {\n        eventQueue.add(event);\n    }\n\n    public static Runnable getNextEvent() {\n        return eventQueue.poll(); // Polls and removes\n    }\n}",
        "hint": "Ensure items are removed from static queues or lists once they are processed."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Deadlock with two locks (Lang: Java, Q17)",
        "buggyCode": "public class ResourceUser {\n    private Object resA = new Object();\n    private Object resB = new Object();\n\n    public void useAthenB() {\n        synchronized (resA) {\n            System.out.println(\"Holding A\");\n            synchronized (resB) {\n                System.out.println(\"Holding A and B\");\n            }\n        }\n    }\n\n    public void useBthenA() {\n        synchronized (resB) {\n            System.out.println(\"Holding B\");\n            synchronized (resA) {\n                System.out.println(\"Holding B and A\");\n            }\n        }\n    }\n}",
        "correctCode": "public class ResourceUser {\n    private Object resA = new Object();\n    private Object resB = new Object();\n\n    public void useAthenB() {\n        synchronized (resA) {\n            System.out.println(\"Holding A\");\n            synchronized (resB) {\n                System.out.println(\"Holding A and B\");\n            }\n        }\n    }\n\n    public void useBthenA() {\n        synchronized (resA) { // Consistent order: always A then B\n            System.out.println(\"Holding A\");\n            synchronized (resB) {\n                System.out.println(\"Holding A and B\");\n            }\n        }\n    }\n}",
        "hint": "Establish a global ordering of locks to prevent deadlocks."
      },
      {
        "language": "Java",
        "bugType": "Resource Leak",
        "description": "Not closing database connection (Lang: Java, Q18)",
        "buggyCode": "import java.sql.*;\n\npublic class ConnectionManager {\n    public void fetchData() throws SQLException {\n        Connection conn = DriverManager.getConnection(\"jdbc:example\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(\"SELECT * FROM users\");\n        // Resources are not closed\n    }\n}",
        "correctCode": "import java.sql.*;\n\npublic class ConnectionManager {\n    public void fetchData() throws SQLException {\n        try (Connection conn = DriverManager.getConnection(\"jdbc:example\");\n             Statement stmt = conn.createStatement();\n             ResultSet rs = stmt.executeQuery(\"SELECT * FROM users\")) {\n            // Use rs\n        }\n    }\n}",
        "hint": "Use try-with-resources for database resources (Connection, Statement, ResultSet)."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Non-volatile field used in multithreading (Lang: Java, Q19)",
        "buggyCode": "class DataCache {\n    private int cachedValue = 0;\n\n    public void setValue(int val) {\n        this.cachedValue = val;\n    }\n\n    public int getValue() {\n        return this.cachedValue;\n    }\n}",
        "correctCode": "class DataCache {\n    private volatile int cachedValue = 0;\n\n    public void setValue(int val) {\n        this.cachedValue = val;\n    }\n\n    public int getValue() {\n        return this.cachedValue;\n    }\n}",
        "hint": "Without `volatile`, changes made by one thread to `cachedValue` might not be immediately visible to other threads."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Incorrect use of `ThreadLocal` leading to leaks (Lang: Java, Q20)",
        "buggyCode": "import java.lang.ThreadLocal;\n\npublic class ThreadLocalUser {\n    private static final ThreadLocal<StringBuilder> threadLocalBuffer = new ThreadLocal<StringBuilder>();\n\n    public StringBuilder getBuffer() {\n        if (threadLocalBuffer.get() == null) {\n            threadLocalBuffer.set(new StringBuilder());\n        }\n        return threadLocalBuffer.get();\n    }\n    // No call to remove() means buffer persists for the thread's life\n}",
        "correctCode": "import java.lang.ThreadLocal;\n\npublic class ThreadLocalUser {\n    private static final ThreadLocal<StringBuilder> threadLocalBuffer = new ThreadLocal<StringBuilder>();\n\n    public StringBuilder getBuffer() {\n        if (threadLocalBuffer.get() == null) {\n            threadLocalBuffer.set(new StringBuilder());\n        }\n        return threadLocalBuffer.get();\n    }\n\n    public void clearBuffer() {\n        threadLocalBuffer.remove(); // Essential to prevent leaks in thread pools\n    }\n}",
        "hint": "Always call `remove()` on `ThreadLocal` variables after use to prevent memory leaks in reusable threads."
      }
    ],
    "hard": [
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Improper synchronization leading to data inconsistency (Lang: Java, Q1)",
        "buggyCode": "class BankAccount {\n    private double balance = 0;\n\n    public void deposit(double amount) {\n        balance += amount;\n    }\n\n    public void withdraw(double amount) {\n        balance -= amount;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n}",
        "correctCode": "class BankAccount {\n    private double balance = 0;\n\n    public synchronized void deposit(double amount) {\n        balance += amount;\n    }\n\n    public synchronized void withdraw(double amount) {\n        balance -= amount;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n}",
        "hint": "Operations on shared mutable state (like `balance`) must be synchronized to prevent race conditions and ensure data consistency."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Unclosed resources in try-catch without finally (Lang: Java, Q2)",
        "buggyCode": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileWriterExample {\n    public void writeToFile(String filename, String data) {\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(filename);\n            fos.write(data.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // fos might not be closed if exception occurs\n    }\n}",
        "correctCode": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileWriterExample {\n    public void writeToFile(String filename, String data) {\n        try (FileOutputStream fos = new FileOutputStream(filename)) {\n            fos.write(data.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "hint": "Use `try-with-resources` or a `finally` block to ensure resources are closed, even if exceptions occur."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `wait()` and `notify()` without loops (Lang: Java, Q3)",
        "buggyCode": "class SharedResource {\n    private boolean produced = false;\n    public synchronized void consume() {\n        if (!produced) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        System.out.println(\"Consumed\");\n        produced = false;\n    }\n    public synchronized void produce() {\n        System.out.println(\"Produced\");\n        produced = true;\n        notify();\n    }\n}",
        "correctCode": "class SharedResource {\n    private boolean produced = false;\n    public synchronized void consume() {\n        while (!produced) { // Use loop for wait condition\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        System.out.println(\"Consumed\");\n        produced = false;\n    }\n    public synchronized void produce() {\n        System.out.println(\"Produced\");\n        produced = true;\n        notifyAll(); // Use notifyAll to wake up all waiting threads\n    }\n}",
        "hint": "Always use `wait()` inside a loop (`while`) to guard against spurious wakeups and ensure the condition is truly met. Use `notifyAll()` to wake up all relevant threads."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Incorrect implementation of `equals()` and `hashCode()` (Lang: Java, Q4)",
        "buggyCode": "import java.util.HashSet;\nimport java.util.Set;\n\nclass CustomKey {\n    int id;\n    String name;\n    public CustomKey(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n    // No equals() or hashCode() override\n}\n\npublic class MapLeak {\n    public static void main(String[] args) {\n        Set<CustomKey> set = new HashSet<>();\n        CustomKey k1 = new CustomKey(1, \"test\");\n        CustomKey k2 = new CustomKey(1, \"test\");\n        set.add(k1);\n        set.add(k2);\n        System.out.println(set.size()); // Should be 1, but might be 2\n    }\n}",
        "correctCode": "import java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\nclass CustomKey {\n    int id;\n    String name;\n    public CustomKey(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        CustomKey customKey = (CustomKey) o;\n        return id == customKey.id && Objects.equals(name, customKey.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, name);\n    }\n}\n\npublic class MapLeak {\n    public static void main(String[] args) {\n        Set<CustomKey> set = new HashSet<>();\n        CustomKey k1 = new CustomKey(1, \"test\");\n        CustomKey k2 = new CustomKey(1, \"test\");\n        set.add(k1);\n        set.add(k2);\n        System.out.println(set.size());\n    }\n}",
        "hint": "When overriding `equals()`, you must also override `hashCode()` to maintain the contract, especially for use in hash-based collections (`HashMap`, `HashSet`)."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Improper synchronization leading to data inconsistency (Lang: Java, Q5)",
        "buggyCode": "class SharedData {\n    private int data = 0;\n\n    public void write(int value) {\n        data = value;\n    }\n\n    public int read() {\n        return data;\n    }\n}",
        "correctCode": "class SharedData {\n    private volatile int data = 0; // Use volatile for visibility\n\n    // Or synchronize methods for atomic operations on complex objects:\n    public synchronized void write(int value) {\n        data = value;\n    }\n\n    public synchronized int read() {\n        return data;\n    }\n}",
        "hint": "Without proper synchronization (like `volatile` or `synchronized`), changes made by one thread might not be visible to others."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Unclosed resources in try-catch without finally (Lang: Java, Q6)",
        "buggyCode": "import java.io.PrintWriter;\nimport java.io.FileNotFoundException;\n\npublic class LogWriter {\n    public void logMessage(String msg) {\n        PrintWriter writer = null;\n        try {\n            writer = new PrintWriter(\"log.txt\");\n            writer.println(msg);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        // writer is not closed\n    }\n}",
        "correctCode": "import java.io.PrintWriter;\nimport java.io.FileNotFoundException;\n\npublic class LogWriter {\n    public void logMessage(String msg) {\n        try (PrintWriter writer = new PrintWriter(\"log.txt\")) {\n            writer.println(msg);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "hint": "Ensure `PrintWriter` resources are closed using `try-with-resources`."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `wait()` and `notify()` without loops (Lang: Java, Q7)",
        "buggyCode": "class ProducerConsumer {\n    private int item = 0;\n    private boolean hasItem = false;\n\n    public synchronized void produce(int value) {\n        if (hasItem) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        item = value;\n        hasItem = true;\n        notify();\n    }\n\n    public synchronized int consume() {\n        if (!hasItem) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        hasItem = false;\n        notify();\n        return item;\n    }\n}",
        "correctCode": "class ProducerConsumer {\n    private int item = 0;\n    private boolean hasItem = false;\n\n    public synchronized void produce(int value) {\n        while (hasItem) { // Loop for robust waiting\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        item = value;\n        hasItem = true;\n        notifyAll(); // Notify all potentially waiting consumers/producers\n    }\n\n    public synchronized int consume() {\n        while (!hasItem) { // Loop for robust waiting\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        hasItem = false;\n        notifyAll();\n        return item;\n    }\n}",
        "hint": "Use `while` loops for `wait()` conditions and `notifyAll()` to avoid missed signals and deadlocks in producer-consumer scenarios."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Incorrect implementation of `equals()` and `hashCode()` (Lang: Java, Q8)",
        "buggyCode": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Coordinate {\n    int x, y;\n    public Coordinate(int x, int y) { this.x = x; this.y = y; }\n}\n\npublic class HashBug {\n    public static void main(String[] args) {\n        Map<Coordinate, String> map = new HashMap<>();\n        map.put(new Coordinate(1, 1), \"A\");\n        System.out.println(map.get(new Coordinate(1, 1))); // Should find 'A' but returns null\n    }\n}",
        "correctCode": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\nclass Coordinate {\n    int x, y;\n    public Coordinate(int x, int y) { this.x = x; this.y = y; }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Coordinate that = (Coordinate) o;\n        return x == that.x && y == that.y;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n}\n\npublic class HashBug {\n    public static void main(String[] args) {\n        Map<Coordinate, String> map = new HashMap<>();\n        map.put(new Coordinate(1, 1), \"A\");\n        System.out.println(map.get(new Coordinate(1, 1)));\n    }\n}",
        "hint": "For custom objects used as keys in hash-based collections, both `equals()` and `hashCode()` must be correctly overridden."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Improper synchronization leading to data inconsistency (Lang: Java, Q9)",
        "buggyCode": "class DataProcessor {\n    private StringBuilder log = new StringBuilder();\n\n    public void appendLog(String message) {\n        log.append(message);\n    }\n\n    public String getLog() {\n        return log.toString();\n    }\n}",
        "correctCode": "class DataProcessor {\n    private StringBuilder log = new StringBuilder();\n\n    public synchronized void appendLog(String message) {\n        log.append(message);\n    }\n\n    public synchronized String getLog() {\n        return log.toString();\n    }\n}",
        "hint": "`StringBuilder` is not thread-safe. Use `StringBuffer` or `synchronized` methods for concurrent access."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Unclosed resources in try-catch without finally (Lang: Java, Q10)",
        "buggyCode": "import java.sql.*;\n\npublic class DBConnector {\n    public void executeUpdate(String sql) {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = DriverManager.getConnection(\"jdbc:url\");\n            stmt = conn.createStatement();\n            stmt.executeUpdate(sql);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        // conn and stmt are not closed\n    }\n}",
        "correctCode": "import java.sql.*;\n\npublic class DBConnector {\n    public void executeUpdate(String sql) {\n        try (Connection conn = DriverManager.getConnection(\"jdbc:url\");\n             Statement stmt = conn.createStatement()) {\n            stmt.executeUpdate(sql);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "hint": "JDBC resources like Connection and Statement must be closed, ideally using try-with-resources."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Improper synchronization leading to data inconsistency (Lang: Java, Q11)",
        "buggyCode": "class BankAccount {\n    private double balance = 0;\n\n    public void deposit(double amount) {\n        balance += amount;\n    }\n\n    public void withdraw(double amount) {\n        balance -= amount;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n}",
        "correctCode": "class BankAccount {\n    private double balance = 0;\n\n    public synchronized void deposit(double amount) {\n        balance += amount;\n    }\n\n    public synchronized void withdraw(double amount) {\n        balance -= amount;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n}",
        "hint": "Operations on shared mutable state (like `balance`) must be synchronized to prevent race conditions and ensure data consistency."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Unclosed resources in try-catch without finally (Lang: Java, Q12)",
        "buggyCode": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileWriterExample {\n    public void writeToFile(String filename, String data) {\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(filename);\n            fos.write(data.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "correctCode": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileWriterExample {\n    public void writeToFile(String filename, String data) {\n        try (FileOutputStream fos = new FileOutputStream(filename)) {\n            fos.write(data.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "hint": "Use `try-with-resources` or a `finally` block to ensure resources are closed, even if exceptions occur."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `wait()` and `notify()` without loops (Lang: Java, Q13)",
        "buggyCode": "class SharedResource {\n    private boolean produced = false;\n    public synchronized void consume() {\n        if (!produced) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        System.out.println(\"Consumed\");\n        produced = false;\n    }\n    public synchronized void produce() {\n        System.out.println(\"Produced\");\n        produced = true;\n        notify();\n    }\n}",
        "correctCode": "class SharedResource {\n    private boolean produced = false;\n    public synchronized void consume() {\n        while (!produced) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        System.out.println(\"Consumed\");\n        produced = false;\n    }\n    public synchronized void produce() {\n        System.out.println(\"Produced\");\n        produced = true;\n        notifyAll();\n    }\n}",
        "hint": "Always use `wait()` inside a loop (`while`) to guard against spurious wakeups and ensure the condition is truly met. Use `notifyAll()` to wake up all relevant threads."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Incorrect implementation of `equals()` and `hashCode()` (Lang: Java, Q14)",
        "buggyCode": "import java.util.HashSet;\nimport java.util.Set;\n\nclass CustomId {\n    int id;\n    public CustomId(int id) {\n        this.id = id;\n    }\n}\n\npublic class SetBug {\n    public static void main(String[] args) {\n        Set<CustomId> set = new HashSet<>();\n        CustomId i1 = new CustomId(1);\n        CustomId i2 = new CustomId(1);\n        set.add(i1);\n        set.add(i2);\n        System.out.println(set.size());\n    }\n}",
        "correctCode": "import java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\nclass CustomId {\n    int id;\n    public CustomId(int id) {\n        this.id = id;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        CustomId customId = (CustomId) o;\n        return id == customId.id;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n}\n\npublic class SetBug {\n    public static void main(String[] args) {\n        Set<CustomId> set = new HashSet<>();\n        CustomId i1 = new CustomId(1);\n        CustomId i2 = new CustomId(1);\n        set.add(i1);\n        set.add(i2);\n        System.out.println(set.size());\n    }\n}",
        "hint": "When overriding `equals()`, you must also override `hashCode()` for objects used in hash-based collections."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Improper synchronization leading to data inconsistency (Lang: Java, Q15)",
        "buggyCode": "class DataStore {\n    private int[] data = {0, 0, 0};\n\n    public void updateData(int index, int value) {\n        data[index] = value;\n    }\n\n    public int getData(int index) {\n        return data[index];\n    }\n}",
        "correctCode": "import java.util.concurrent.atomic.AtomicIntegerArray;\n\nclass DataStore {\n    private AtomicIntegerArray data = new AtomicIntegerArray(new int[]{0, 0, 0});\n\n    public void updateData(int index, int value) {\n        data.set(index, value);\n    }\n\n    public int getData(int index) {\n        return data.get(index);\n    }\n}",
        "hint": "Array access is not atomic; for concurrent array manipulation, use `AtomicIntegerArray` or explicit synchronization."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Unclosed resources in try-catch without finally (Lang: Java, Q16)",
        "buggyCode": "import java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class DataReader {\n    public void readBytes(String filePath) throws IOException {\n        FileInputStream fis = new FileInputStream(filePath);\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        int b;\n        while ((b = bis.read()) != -1) {\n            // read byte\n        }\n        // Resources are not closed\n    }\n}",
        "correctCode": "import java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class DataReader {\n    public void readBytes(String filePath) throws IOException {\n        try (FileInputStream fis = new FileInputStream(filePath);\n             BufferedInputStream bis = new BufferedInputStream(fis)) {\n            int b;\n            while ((b = bis.read()) != -1) {\n                // read byte\n            }\n        }\n    }\n}",
        "hint": "Use try-with-resources to ensure both `FileInputStream` and `BufferedInputStream` are closed automatically."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Improper synchronization leading to data inconsistency (Lang: Java, Q17)",
        "buggyCode": "class ValueHolder {\n    private int value = 0;\n\n    public void increment() {\n        value++;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}",
        "correctCode": "class ValueHolder {\n    private volatile int value = 0;\n\n    public synchronized void increment() {\n        value++;\n    }\n\n    public int getValue() {\n        return value;\n    }\n}",
        "hint": "Atomic operations (`value++`) on shared primitives need `synchronized` or `AtomicInteger`."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Incorrect implementation of `equals()` and `hashCode()` (Lang: Java, Q18)",
        "buggyCode": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Person {\n    String name;\n    int age;\n    public Person(String name, int age) { this.name = name; this.age = age; }\n}\n\npublic class PersonMap {\n    public static void main(String[] args) {\n        Map<Person, String> users = new HashMap<>();\n        users.put(new Person(\"Alice\", 30), \"user1\");\n        System.out.println(users.get(new Person(\"Alice\", 30)));\n    }\n}",
        "correctCode": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\nclass Person {\n    String name;\n    int age;\n    public Person(String name, int age) { this.name = name; this.age = age; }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age && Objects.equals(name, person.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}\n\npublic class PersonMap {\n    public static void main(String[] args) {\n        Map<Person, String> users = new HashMap<>();\n        users.put(new Person(\"Alice\", 30), \"user1\");\n        System.out.println(users.get(new Person(\"Alice\", 30)));\n    }\n}",
        "hint": "Custom objects used as keys in `HashMap` require consistent `equals()` and `hashCode()` implementations."
      },
      {
        "language": "Java",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `wait()` and `notify()` without loops (Lang: Java, Q19)",
        "buggyCode": "class MessageQueue {\n    private String message = null;\n\n    public synchronized void put(String msg) {\n        if (message != null) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        message = msg;\n        notify();\n    }\n\n    public synchronized String take() {\n        if (message == null) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        String temp = message;\n        message = null;\n        notify();\n        return temp;\n    }\n}",
        "correctCode": "class MessageQueue {\n    private String message = null;\n\n    public synchronized void put(String msg) {\n        while (message != null) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        message = msg;\n        notifyAll();\n    }\n\n    public synchronized String take() {\n        while (message == null) {\n            try { wait(); } catch (InterruptedException e) {}\n        }\n        String temp = message;\n        message = null;\n        notifyAll();\n        return temp;\n    }\n}",
        "hint": "`wait()` should always be called in a `while` loop to re-check the condition upon waking. Use `notifyAll()` to wake all relevant threads."
      },
      {
        "language": "Java",
        "bugType": "Memory Leak",
        "description": "Unclosed resources in try-catch without finally (Lang: Java, Q20)",
        "buggyCode": "import java.io.InputStream;\nimport java.net.URL;\n\npublic class URLReader {\n    public void readURL(String urlString) {\n        InputStream is = null;\n        try {\n            URL url = new URL(urlString);\n            is = url.openStream();\n            int data;\n            while ((data = is.read()) != -1) {\n                // process data\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // is is not closed\n    }\n}",
        "correctCode": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class URLReader {\n    public void readURL(String urlString) {\n        try (InputStream is = new URL(urlString).openStream()) {\n            int data;\n            while ((data = is.read()) != -1) {\n                // process data\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "hint": "Network streams also need to be closed properly using `try-with-resources`."
      }
    ]
  },
  "DotNet": {
    "easy": [
      {
        "language": "DotNet",
        "bugType": "Syntax Error",
        "description": "Missing semicolon at end of statement (Lang: DotNet, Q1)",
        "buggyCode": "using System;\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        Console.WriteLine(\"Hello DotNet\")\n    }\n}",
        "correctCode": "using System;\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        Console.WriteLine(\"Hello DotNet\");\n    }\n}",
        "hint": "C# statements typically end with a semicolon."
      },
      {
        "language": "DotNet",
        "bugType": "Logic Error",
        "description": "Incorrect comparison operator (Lang: DotNet, Q2)",
        "buggyCode": "int age = 17;\nif (age > 18) {\n    Console.WriteLine(\"Eligible to vote\");\n}",
        "correctCode": "int age = 17;\nif (age >= 18) {\n    Console.WriteLine(\"Eligible to vote\");\n}",
        "hint": "Consider edge cases for age boundaries (e.g., exactly 18)."
      },
      {
        "language": "DotNet",
        "bugType": "Type Mismatch",
        "description": "Implicit conversion failure (Lang: DotNet, Q3)",
        "buggyCode": "int number = \"123\";",
        "correctCode": "int number = 123; // Or: int number = int.Parse(\"123\");",
        "hint": "Cannot implicitly convert string to int. Use `int.Parse()` or `Convert.ToInt32()`."
      },
      {
        "language": "DotNet",
        "bugType": "NullReferenceException",
        "description": "Dereferencing a null object (Lang: DotNet, Q4)",
        "buggyCode": "string name = null;\nConsole.WriteLine(name.Length);",
        "correctCode": "string name = \"John Doe\";\nConsole.WriteLine(name.Length);",
        "hint": "Always check for null before accessing members of a reference type."
      },
      {
        "language": "DotNet",
        "bugType": "IndexOutOfRangeException",
        "description": "Accessing array out of bounds (Lang: DotNet, Q5)",
        "buggyCode": "int[] numbers = {1, 2, 3};\nConsole.WriteLine(numbers[3]);",
        "correctCode": "int[] numbers = {1, 2, 3};\nConsole.WriteLine(numbers[2]);",
        "hint": "Array indices are 0-based. The last valid index is `Length - 1`."
      },
      {
        "language": "DotNet",
        "bugType": "Syntax Error",
        "description": "Missing curly brace (Lang: DotNet, Q6)",
        "buggyCode": "public class MyClass\n{\n    public void MyMethod()\n    {\n        Console.WriteLine(\"Hello\");\n}",
        "correctCode": "public class MyClass\n{\n    public void MyMethod()\n    {\n        Console.WriteLine(\"Hello\");\n    }\n}",
        "hint": "All code blocks must be enclosed by curly braces."
      },
      {
        "language": "DotNet",
        "bugType": "Logic Error",
        "description": "Incorrect boolean assignment (Lang: DotNet, Q7)",
        "buggyCode": "bool isActive = false;\nif (isActive = true) {\n    Console.WriteLine(\"Active\");\n}",
        "correctCode": "bool isActive = false;\nif (isActive == true) {\n    Console.WriteLine(\"Active\");\n}",
        "hint": "Use `==` for comparison, not `=` for assignment in conditions."
      },
      {
        "language": "DotNet",
        "bugType": "Type Mismatch",
        "description": "Attempting to assign float to int without cast (Lang: DotNet, Q8)",
        "buggyCode": "int value = 10.5f;",
        "correctCode": "int value = (int)10.5f;",
        "hint": "Explicit casting is required for narrowing conversions from float to int."
      },
      {
        "language": "DotNet",
        "bugType": "NullReferenceException",
        "description": "Dereferencing a null object (Lang: DotNet, Q9)",
        "buggyCode": "List<string> items = null;\nConsole.WriteLine(items.Count);",
        "correctCode": "List<string> items = new List<string>();\nConsole.WriteLine(items.Count);",
        "hint": "Collections must be instantiated before use."
      },
      {
        "language": "DotNet",
        "bugType": "IndexOutOfRangeException",
        "description": "Accessing list out of bounds (Lang: DotNet, Q10)",
        "buggyCode": "List<int> data = new List<int> {10, 20};\nConsole.WriteLine(data[2]);",
        "correctCode": "List<int> data = new List<int> {10, 20};\nConsole.WriteLine(data[1]);",
        "hint": "List indices range from 0 to `Count - 1`."
      },
      {
        "language": "DotNet",
        "bugType": "Syntax Error",
        "description": "Missing namespace reference (Lang: DotNet, Q11)",
        "buggyCode": "public class Example {\n    public void Method() {\n        var list = new List<int>();\n    }\n}",
        "correctCode": "using System.Collections.Generic;\n\npublic class Example {\n    public void Method() {\n        var list = new List<int>();\n    }\n}",
        "hint": "Many common classes require a `using` directive for their namespace."
      },
      {
        "language": "DotNet",
        "bugType": "Logic Error",
        "description": "Integer division losing precision (Lang: DotNet, Q12)",
        "buggyCode": "int numerator = 10;\nint denominator = 3;\ndouble result = numerator / denominator;\nConsole.WriteLine(result);",
        "correctCode": "int numerator = 10;\nint denominator = 3;\ndouble result = (double)numerator / denominator;\nConsole.WriteLine(result);",
        "hint": "Perform floating-point division by casting at least one operand."
      },
      {
        "language": "DotNet",
        "bugType": "Type Mismatch",
        "description": "Attempting to cast unrelated types (Lang: DotNet, Q13)",
        "buggyCode": "object obj = \"hello\";\nint val = (int)obj;",
        "correctCode": "object obj = 123;\nint val = (int)obj;\n// Or: string s = (string)obj;",
        "hint": "Casting requires an inheritance or conversion relationship."
      },
      {
        "language": "DotNet",
        "bugType": "NullReferenceException",
        "description": "Dereferencing a null object (Lang: DotNet, Q14)",
        "buggyCode": "Dictionary<string, int> dict = null;\ndict.Add(\"one\", 1);",
        "correctCode": "Dictionary<string, int> dict = new Dictionary<string, int>();\ndict.Add(\"one\", 1);",
        "hint": "Dictionaries need to be instantiated before use."
      },
      {
        "language": "DotNet",
        "bugType": "IndexOutOfRangeException",
        "description": "Off-by-one error in loop (Lang: DotNet, Q15)",
        "buggyCode": "int[] values = {5, 6, 7};\nfor (int i = 0; i <= values.Length; i++) {\n    Console.WriteLine(values[i]);\n}",
        "correctCode": "int[] values = {5, 6, 7};\nfor (int i = 0; i < values.Length; i++) {\n    Console.WriteLine(values[i]);\n}",
        "hint": "Loop up to `< Length`, not `<= Length`."
      },
      {
        "language": "DotNet",
        "bugType": "Syntax Error",
        "description": "Missing return type in method (Lang: DotNet, Q16)",
        "buggyCode": "public class Calc {\n    public Sum(int a, int b) {\n        return a + b;\n    }\n}",
        "correctCode": "public class Calc {\n    public int Sum(int a, int b) {\n        return a + b;\n    }\n}",
        "hint": "Every method in C# must declare a return type (or `void`)."
      },
      {
        "language": "DotNet",
        "bugType": "Logic Error",
        "description": "Incorrect string comparison (Lang: DotNet, Q17)",
        "buggyCode": "string s1 = \"hello\";\nstring s2 = \"Hello\";\nif (s1 == s2) {\n    Console.WriteLine(\"Strings are equal\");\n}",
        "correctCode": "string s1 = \"hello\";\nstring s2 = \"Hello\";\nif (s1.Equals(s2, StringComparison.OrdinalIgnoreCase)) {\n    Console.WriteLine(\"Strings are equal\");\n}",
        "hint": "String comparison with `==` is case-sensitive by default. Use `Equals()` with `StringComparison` for more control."
      },
      {
        "language": "DotNet",
        "bugType": "Type Mismatch",
        "description": "Boxing/unboxing issue with value types (Lang: DotNet, Q18)",
        "buggyCode": "object obj = 100;\nshort s = (short)obj;",
        "correctCode": "object obj = 100;\nshort s = (short)(int)obj;",
        "hint": "Unboxing must be to the exact type. You might need multiple casts."
      },
      {
        "language": "DotNet",
        "bugType": "NullReferenceException",
        "description": "Dereferencing a null object (Lang: DotNet, Q19)",
        "buggyCode": "MyClass instance = null;\ninstance.DoSomething();",
        "correctCode": "public class MyClass { public void DoSomething() { Console.WriteLine(\"Done\"); } }\nMyClass instance = new MyClass();\ninstance.DoSomething();",
        "hint": "An object must be instantiated before its methods can be called."
      },
      {
        "language": "DotNet",
        "bugType": "IndexOutOfRangeException",
        "description": "Accessing list out of bounds (Lang: DotNet, Q20)",
        "buggyCode": "List<string> names = new List<string> { \"Alice\" };\nConsole.WriteLine(names[1]);",
        "correctCode": "List<string> names = new List<string> { \"Alice\" };\nConsole.WriteLine(names[0]);",
        "hint": "Check the collection size before accessing elements by index."
      }
    ],
    "medium": [
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Race condition with non-atomic increment (Lang: DotNet, Q1)",
        "buggyCode": "using System;\nusing System.Threading;\n\npublic class Counter\n{\n    public int count = 0;\n    public void Increment()\n    {\n        count++;\n    }\n}\n\n// Simulate with threads\n// Thread 1: counter.Increment();\n// Thread 2: counter.Increment();",
        "correctCode": "using System;\nusing System.Threading;\n\npublic class Counter\n{\n    private int _count = 0;\n    public void Increment()\n    {\n        Interlocked.Increment(ref _count); // Use Interlocked for atomic operations\n    }\n    public int GetCount() { return _count; }\n}\n\n// Or using lock:\n// public class Counter {\n//     private int _count = 0;\n//     private readonly object _lock = new object();\n//     public void Increment() {\n//         lock (_lock) {\n//             _count++;\n//         }\n//     }\n//     public int GetCount() { lock(_lock) { return _count; } }\n// }",
        "hint": "Simple increments (`++`) are not atomic in multi-threaded environments. Use `Interlocked` methods or `lock` keyword."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Static event handler preventing object garbage collection (Lang: DotNet, Q2)",
        "buggyCode": "using System;\nusing System.Collections.Generic;\n\npublic class EventSource\n{\n    public static event Action GlobalEvent;\n    public static void FireEvent() { GlobalEvent?.Invoke(); }\n}\n\npublic class Listener\n{\n    public string Name { get; set; }\n    public Listener(string name)\n    {\n        Name = name;\n        EventSource.GlobalEvent += HandleEvent; // Static event holds reference\n    }\n\n    private void HandleEvent()\n    {\n        Console.WriteLine($\"{Name} handled event\");\n    }\n\n    // No way to unsubscribe or dispose\n}",
        "correctCode": "using System;\nusing System.Collections.Generic;\n\npublic class EventSource\n{\n    public static event Action GlobalEvent;\n    public static void FireEvent() { GlobalEvent?.Invoke(); }\n}\n\npublic class Listener : IDisposable\n{\n    public string Name { get; set; }\n    public Listener(string name)\n    {\n        Name = name;\n        EventSource.GlobalEvent += HandleEvent;\n    }\n\n    private void HandleEvent()\n    {\n        Console.WriteLine($\"{Name} handled event\");\n    }\n\n    public void Dispose()\n    {\n        EventSource.GlobalEvent -= HandleEvent; // Unsubscribe to prevent leak\n    }\n}\n// Usage:\n// using (var listener = new Listener(\"MyListener\")) {\n//    // ...\n// }\n// Or manually call listener.Dispose();",
        "hint": "Static events hold strong references to their subscribers. Always unsubscribe from events to prevent memory leaks."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Deadlock with multiple locks (Lang: DotNet, Q3)",
        "buggyCode": "using System;\nusing System.Threading;\n\npublic class Account\n{\n    public int Id { get; set; }\n    public double Balance { get; set; }\n    private object _lock = new object();\n\n    public void Transfer(Account destination, double amount)\n    {\n        lock (this._lock)\n        {\n            Thread.Sleep(10);\n            lock (destination._lock)\n            {\n                if (Balance >= amount) {\n                    Balance -= amount;\n                    destination.Balance += amount;\n                }\n            }\n        }\n    }\n}\n// Simulating two accounts trying to transfer to each other simultaneously",
        "correctCode": "using System;\nusing System.Threading;\n\npublic class Account\n{\n    public int Id { get; set; }\n    public double Balance { get; set; }\n    private object _lock = new object();\n\n    public void Transfer(Account destination, double amount)\n    {\n        // Ensure consistent lock ordering (e.g., by ID to prevent deadlocks)\n        object lock1 = this.Id < destination.Id ? this._lock : destination._lock;\n        object lock2 = this.Id < destination.Id ? destination._lock : this._lock;\n\n        lock (lock1)\n        {\n            Thread.Sleep(10);\n            lock (lock2)\n            {\n                if (Balance >= amount) {\n                    Balance -= amount;\n                    destination.Balance += amount;\n                }\n            }\n        }\n    }\n}",
        "hint": "Deadlock often occurs when multiple threads acquire locks in different orders. Establish a global ordering for acquiring locks."
      },
      {
        "language": "DotNet",
        "bugType": "Resource Leak",
        "description": "Not disposing IDisposable objects (Lang: DotNet, Q4)",
        "buggyCode": "using System;\nusing System.IO;\n\npublic class FileProcessor\n{\n    public void ReadAndProcess(string path)\n    {\n        StreamReader reader = new StreamReader(path);\n        string line = reader.ReadLine();\n        Console.WriteLine(line);\n        // reader.Dispose() is missing\n    }\n}",
        "correctCode": "using System;\nusing System.IO;\n\npublic class FileProcessor\n{\n    public void ReadAndProcess(string path)\n    {\n        using (StreamReader reader = new StreamReader(path)) // Use 'using' statement\n        {\n            string line = reader.ReadLine();\n            Console.WriteLine(line);\n        }\n    }\n}",
        "hint": "Always dispose of objects that implement `IDisposable` (like streams, database connections) using a `using` statement or explicit `Dispose()` call in a `finally` block."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Non-volatile field leading to stale data (Lang: DotNet, Q5)",
        "buggyCode": "using System;\nusing System.Threading;\n\npublic class StatusFlag\n{\n    private bool _stop = false;\n\n    public void SetStop()\n    {\n        _stop = true;\n    }\n\n    public bool IsStopped()\n    {\n        return _stop;\n    }\n\n    public void RunLoop()\n    {\n        while (!_stop)\n        {\n            // Perform work\n        }\n        Console.WriteLine(\"Loop exited.\");\n    }\n}",
        "correctCode": "using System;\nusing System.Threading;\n\npublic class StatusFlag\n{\n    private volatile bool _stop = false; // Use volatile keyword\n\n    public void SetStop()\n    {\n        _stop = true;\n    }\n\n    public bool IsStopped()\n    {\n        return _stop;\n    }\n\n    public void RunLoop()\n    {\n        while (!_stop)\n        {\n            // Perform work\n        }\n        Console.WriteLine(\"Loop exited.\");\n    }\n}",
        "hint": "`volatile` ensures that reads and writes to a field are always from/to main memory, preventing CPU cache issues in multithreading."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Static event handler preventing object garbage collection (Lang: DotNet, Q6)",
        "buggyCode": "using System;\n\npublic class GlobalPublisher\n{\n    public static event Action OnDataReady;\n    public static void PublishData() { OnDataReady?.Invoke(); }\n}\n\npublic class DataConsumer\n{\n    public DataConsumer()\n    {\n        GlobalPublisher.OnDataReady += HandleData; // Leak: no unsubscribe\n    }\n    private void HandleData() { Console.WriteLine(\"Data received\"); }\n}",
        "correctCode": "using System;\n\npublic class GlobalPublisher\n{\n    public static event Action OnDataReady;\n    public static void PublishData() { OnDataReady?.Invoke(); }\n}\n\npublic class DataConsumer : IDisposable\n{\n    public DataConsumer()\n    {\n        GlobalPublisher.OnDataReady += HandleData;\n    }\n    private void HandleData() { Console.WriteLine(\"Data received\"); }\n    public void Dispose()\n    {\n        GlobalPublisher.OnDataReady -= HandleData; // Unsubscribe\n        GC.SuppressFinalize(this);\n    }\n}",
        "hint": "Objects subscribing to static events need to explicitly unsubscribe when they are no longer needed to prevent memory leaks."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Deadlock with multiple locks (Lang: DotNet, Q7)",
        "buggyCode": "using System.Threading;\n\npublic class DiningPhilosophers\n{\n    private object _forkA = new object();\n    private object _forkB = new object();\n\n    public void EatWithAB()\n    {\n        lock (_forkA)\n        {\n            Thread.Sleep(10);\n            lock (_forkB) { /* Eat */ }\n        }\n    }\n\n    public void EatWithBA()\n    {\n        lock (_forkB)\n        {\n            Thread.Sleep(10);\n            lock (_forkA) { /* Eat */ }\n        }\n    }\n}",
        "correctCode": "using System.Threading;\n\npublic class DiningPhilosophers\n{\n    private object _fork1 = new object();\n    private object _fork2 = new object();\n\n    public void EatWith1Then2()\n    {\n        lock (_fork1)\n        {\n            Thread.Sleep(10);\n            lock (_fork2) { /* Eat */ }\n        }\n    }\n\n    public void EatWith2Then1()\n    {\n        lock (_fork1) // Always acquire in the same order\n        {\n            Thread.Sleep(10);\n            lock (_fork2) { /* Eat */ }\n        }\n    }\n}",
        "hint": "Enforce a consistent ordering for acquiring multiple locks to prevent deadlocks."
      },
      {
        "language": "DotNet",
        "bugType": "Resource Leak",
        "description": "Not disposing IDisposable objects (Lang: DotNet, Q8)",
        "buggyCode": "using System.Data.SqlClient;\n\npublic class DataAccess\n{\n    public void GetData(string connString, string query)\n    {\n        SqlConnection conn = new SqlConnection(connString);\n        conn.Open();\n        SqlCommand cmd = new SqlCommand(query, conn);\n        SqlDataReader reader = cmd.ExecuteReader();\n        // conn, cmd, reader are not disposed\n    }\n}",
        "correctCode": "using System.Data.SqlClient;\n\npublic class DataAccess\n{\n    public void GetData(string connString, string query)\n    {\n        using (SqlConnection conn = new SqlConnection(connString))\n        {\n            conn.Open();\n            using (SqlCommand cmd = new SqlCommand(query, conn))\n            {\n                using (SqlDataReader reader = cmd.ExecuteReader())\n                {\n                    // Use reader\n                }\n            }\n        }\n    }\n}",
        "hint": "Database connections, commands, and readers must be properly disposed using `using` statements."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Non-volatile field leading to stale data (Lang: DotNet, Q9)",
        "buggyCode": "using System;\nusing System.Threading;\n\npublic class SharedCounter\n{\n    private int _value = 0;\n\n    public void SetValue(int val)\n    {\n        _value = val;\n    }\n\n    public int GetValue()\n    {\n        return _value;\n    }\n}",
        "correctCode": "using System;\nusing System.Threading;\n\npublic class SharedCounter\n{\n    private volatile int _value = 0; // Ensure visibility with volatile\n\n    public void SetValue(int val)\n    {\n        _value = val;\n    }\n\n    public int GetValue()\n    {\n        return _value;\n    }\n}",
        "hint": "When a field is accessed by multiple threads, `volatile` ensures memory barrier operations for visibility."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Improperly used `WeakReference` for caching (Lang: DotNet, Q10)",
        "buggyCode": "using System;\nusing System.Collections.Generic;\n\npublic class ObjectCache\n{\n    private static Dictionary<string, WeakReference<object>> cache = new Dictionary<string, WeakReference<object>>();\n\n    public static void Add(string key, object obj)\n    {\n        cache[key] = new WeakReference<object>(obj);\n    }\n\n    public static object Get(string key)\n    {\n        if (cache.TryGetValue(key, out WeakReference<object> weakRef))\n        {\n            return weakRef.TryGetTarget(out object target) ? target : null;\n        }\n        return null;\n    }\n\n    // Problem: Dictionary itself can grow unbounded, even if objects are collected\n}",
        "correctCode": "using System;\nusing System.Collections.Generic;\n\npublic class ObjectCache\n{\n    private static Dictionary<string, WeakReference<object>> cache = new Dictionary<string, WeakReference<object>>();\n\n    public static void Add(string key, object obj)\n    {\n        cache[key] = new WeakReference<object>(obj);\n    }\n\n    public static object Get(string key)\n    {\n        if (cache.TryGetValue(key, out WeakReference<object> weakRef))\n        {\n            return weakRef.TryGetTarget(out object target) ? target : null;\n        }\n        return null;\n    }\n\n    public static void CleanCache()\n    {\n        // Periodically clean up collected entries\n        var keysToRemove = new List<string>();\n        foreach (var entry in cache)\n        {\n            if (!entry.Value.TryGetTarget(out _))\n            {\n                keysToRemove.Add(entry.Key);\n            }\n        }\n        foreach (var key in keysToRemove)\n        {\n            cache.Remove(key);\n        }\n    }\n}",
        "hint": "Even with `WeakReference`, the dictionary entries themselves are strong references. Periodically clean up entries whose targets have been garbage collected."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Race condition with non-atomic increment (Lang: DotNet, Q11)",
        "buggyCode": "using System;\nusing System.Threading;\n\npublic class Counter\n{\n    public int value = 0;\n    public void Add()\n    {\n        value++;\n    }\n}",
        "correctCode": "using System;\nusing System.Threading;\n\npublic class Counter\n{\n    private int _value = 0;\n    public void Add()\n    {\n        Interlocked.Increment(ref _value);\n    }\n    public int GetValue() { return _value; }\n}",
        "hint": "Operations like `++` are not atomic and require explicit synchronization or `Interlocked`."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Static event handler preventing object garbage collection (Lang: DotNet, Q12)",
        "buggyCode": "using System;\n\npublic class GlobalNotifier\n{\n    public static event Action NotifyAll;\n    public static void Trigger() { NotifyAll?.Invoke(); }\n}\n\npublic class Subscriber\n{\n    public Subscriber() { GlobalNotifier.NotifyAll += OnNotify; }\n    private void OnNotify() { Console.WriteLine(\"Notified\"); }\n}",
        "correctCode": "using System;\n\npublic class GlobalNotifier\n{\n    public static event Action NotifyAll;\n    public static void Trigger() { NotifyAll?.Invoke(); }\n}\n\npublic class Subscriber : IDisposable\n{\n    public Subscriber() { GlobalNotifier.NotifyAll += OnNotify; }\n    private void OnNotify() { Console.WriteLine(\"Notified\"); }\n    public void Dispose()\n    {\n        GlobalNotifier.NotifyAll -= OnNotify;\n        GC.SuppressFinalize(this);\n    }\n}",
        "hint": "Classes subscribing to static events must unsubscribe to avoid memory leaks."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Deadlock with multiple locks (Lang: DotNet, Q13)",
        "buggyCode": "using System.Threading;\n\npublic class BankTransfer\n{\n    private readonly object _lockA = new object();\n    private readonly object _lockB = new object();\n\n    public void TransferFunds(Account source, Account dest, decimal amount)\n    {\n        if (source.Id < dest.Id) {\n            lock (_lockA) { lock (_lockB) { /* transfer */ } }\n        } else {\n            lock (_lockB) { lock (_lockA) { /* transfer */ } }\n        }\n    }\n}\n// Issue: uses _lockA and _lockB instead of account-specific locks",
        "correctCode": "using System.Threading;\n\npublic class BankTransfer\n{\n    public void TransferFunds(Account source, Account dest, decimal amount)\n    {\n        object lock1 = source.Id < dest.Id ? source.SyncRoot : dest.SyncRoot; // Assuming SyncRoot property on Account\n        object lock2 = source.Id < dest.Id ? dest.SyncRoot : source.SyncRoot;\n\n        lock (lock1)\n        {\n            lock (lock2)\n            {\n                // Perform transfer logic\n            }\n        }\n    }\n}\n// Requires Account class to have a SyncRoot or unique lock object per instance",
        "hint": "Use unique lock objects per instance (e.g., per account) and enforce a consistent locking order across instances to prevent deadlocks."
      },
      {
        "language": "DotNet",
        "bugType": "Resource Leak",
        "description": "Not disposing IDisposable objects (Lang: DotNet, Q14)",
        "buggyCode": "using System.Net.Http;\n\npublic class WebClient {\n    public async Task<string> FetchData(string url) {\n        HttpClient client = new HttpClient();\n        string data = await client.GetStringAsync(url);\n        // client is not disposed\n        return data;\n    }\n}",
        "correctCode": "using System.Net.Http;\n\npublic class WebClient {\n    public async Task<string> FetchData(string url) {\n        using (HttpClient client = new HttpClient()) {\n            string data = await client.GetStringAsync(url);\n            return data;\n        }\n    }\n}",
        "hint": "HttpClient implements IDisposable and should be disposed when no longer needed (or reused for long-running applications)."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Non-volatile field leading to stale data (Lang: DotNet, Q15)",
        "buggyCode": "using System;\nusing System.Threading;\n\npublic class SharedFlag\n{\n    private bool _flag = false;\n\n    public void SetFlag()\n    {\n        _flag = true;\n    }\n\n    public bool GetFlag()\n    {\n        return _flag;\n    }\n}",
        "correctCode": "using System;\nusing System.Threading;\n\npublic class SharedFlag\n{\n    private volatile bool _flag = false;\n\n    public void SetFlag()\n    {\n        _flag = true;\n    }\n\n    public bool GetFlag()\n    {\n        return _flag;\n    }\n}",
        "hint": "`volatile` ensures that changes to a field are immediately visible to all threads, avoiding stale cached values."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Static event handler preventing object garbage collection (Lang: DotNet, Q16)",
        "buggyCode": "using System;\n\npublic class GlobalMonitor\n{\n    public static event Action OnUpdate;\n    public static void TriggerUpdate() { OnUpdate?.Invoke(); }\n}\n\npublic class ReportingService\n{\n    public ReportingService() { GlobalMonitor.OnUpdate += GenerateReport; }\n    private void GenerateReport() { Console.WriteLine(\"Report generated\"); }\n}",
        "correctCode": "using System;\n\npublic class GlobalMonitor\n{\n    public static event Action OnUpdate;\n    public static void TriggerUpdate() { OnUpdate?.Invoke(); }\n}\n\npublic class ReportingService : IDisposable\n{\n    public ReportingService() { GlobalMonitor.OnUpdate += GenerateReport; }\n    private void GenerateReport() { Console.WriteLine(\"Report generated\"); }\n    public void Dispose()\n    {\n        GlobalMonitor.OnUpdate -= GenerateReport;\n        GC.SuppressFinalize(this);\n    }\n}",
        "hint": "Subscribers to static events must explicitly unsubscribe to prevent the subscriber instance from being kept alive."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Deadlock with multiple locks (Lang: DotNet, Q17)",
        "buggyCode": "using System.Threading;\n\npublic class ResourceLocker\n{\n    private readonly object _resource1 = new object();\n    private readonly object _resource2 = new object();\n\n    public void Acquire1then2()\n    {\n        lock (_resource1) { lock (_resource2) { /* Use resources */ } }\n    }\n\n    public void Acquire2then1()\n    {\n        lock (_resource2) { lock (_resource1) { /* Use resources */ } }\n    }\n}",
        "correctCode": "using System.Threading;\n\npublic class ResourceLocker\n{\n    private readonly object _resource1 = new object();\n    private readonly object _resource2 = new object();\n\n    public void Acquire1then2()\n    {\n        lock (_resource1) { lock (_resource2) { /* Use resources */ } }\n    }\n\n    public void Acquire2then1()\n    {\n        lock (_resource1) { lock (_resource2) { /* Use resources */ } }\n    }\n}",
        "hint": "Consistent lock ordering is critical for avoiding deadlocks."
      },
      {
        "language": "DotNet",
        "bugType": "Resource Leak",
        "description": "Not disposing IDisposable objects (Lang: DotNet, Q18)",
        "buggyCode": "using System.Net.Sockets;\n\npublic class SocketClient {\n    public void ConnectAndSend(string host, int port, string message) {\n        Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n        socket.Connect(host, port);\n        byte[] data = System.Text.Encoding.ASCII.GetBytes(message);\n        socket.Send(data);\n        // socket is not disposed\n    }\n}",
        "correctCode": "using System.Net.Sockets;\n\npublic class SocketClient {\n    public void ConnectAndSend(string host, int port, string message) {\n        using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)) {\n            socket.Connect(host, port);\n            byte[] data = System.Text.Encoding.ASCII.GetBytes(message);\n            socket.Send(data);\n        }\n    }\n}",
        "hint": "Network sockets are unmanaged resources and require explicit disposal."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Non-volatile field leading to stale data (Lang: DotNet, Q19)",
        "buggyCode": "using System;\nusing System.Threading;\n\npublic class CacheUpdater\n{\n    private bool _dataReady = false;\n\n    public void MarkDataReady()\n    {\n        _dataReady = true;\n    }\n\n    public bool IsDataReady()\n    {\n        return _dataReady;\n    }\n}",
        "correctCode": "using System;\nusing System.Threading;\n\npublic class CacheUpdater\n{\n    private volatile bool _dataReady = false;\n\n    public void MarkDataReady()\n    {\n        _dataReady = true;\n    }\n\n    public bool IsDataReady()\n    {\n        return _dataReady;\n    }\n}",
        "hint": "`volatile` ensures that writes to the field are immediately visible and reads are always from the latest value."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Improperly used `WeakReference` for caching (Lang: DotNet, Q20)",
        "buggyCode": "using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\n\npublic class SharedCache\n{\n    private static ConcurrentDictionary<string, WeakReference<object>> _cache = new ConcurrentDictionary<string, WeakReference<object>>();\n\n    public static void AddItem(string key, object item)\n    {\n        _cache[key] = new WeakReference<object>(item);\n    }\n\n    public static object GetItem(string key)\n    {\n        if (_cache.TryGetValue(key, out var weakRef))\n        {\n            return weakRef.TryGetTarget(out var target) ? target : null;\n        }\n        return null;\n    }\n    // No mechanism to remove collected weak references from the dictionary\n}",
        "correctCode": "using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\n\npublic class SharedCache\n{\n    private static ConcurrentDictionary<string, WeakReference<object>> _cache = new ConcurrentDictionary<string, WeakReference<object>>();\n\n    public static void AddItem(string key, object item)\n    {\n        _cache[key] = new WeakReference<object>(item);\n    }\n\n    public static object GetItem(string key)\n    {\n        if (_cache.TryGetValue(key, out var weakRef))\n        {\n            if (weakRef.TryGetTarget(out var target))\n            {\n                return target;\n            }\n            else\n            {\n                // Remove the entry if the target has been collected\n                _cache.TryRemove(key, out _);\n            }\n        }\n        return null;\n    }\n\n    public static void CleanUpCollectedEntries()\n    {\n        foreach (var entry in _cache)\n        {\n            if (!entry.Value.TryGetTarget(out _))\n            {\n                _cache.TryRemove(entry.Key, out _);\n            }\n        }\n    }\n}",
        "hint": "A `ConcurrentDictionary` with `WeakReference` still requires explicit cleanup of the dictionary entries once their targets are collected."
      }
    ],
    "hard": [
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `Monitor.Wait` and `Monitor.Pulse` (Lang: DotNet, Q1)",
        "buggyCode": "using System;\nusing System.Threading;\n\npublic class ProducerConsumer\n{\n    private Queue<int> _queue = new Queue<int>();\n    private readonly int _capacity = 5;\n\n    public void Produce(int item)\n    {\n        lock (_queue)\n        {\n            if (_queue.Count == _capacity)\n            {\n                Monitor.Wait(_queue); // Should be in a loop\n            }\n            _queue.Enqueue(item);\n            Console.WriteLine($\"Produced: {item}\");\n            Monitor.Pulse(_queue); // Should be PulseAll\n        }\n    }\n\n    public int Consume()\n    {\n        lock (_queue)\n        {\n            if (_queue.Count == 0)\n            {\n                Monitor.Wait(_queue); // Should be in a loop\n            }\n            int item = _queue.Dequeue();\n            Console.WriteLine($\"Consumed: {item}\");\n            Monitor.Pulse(_queue);\n            return item;\n        }\n    }\n}",
        "correctCode": "using System;\nusing System.Threading;\nusing System.Collections.Generic;\n\npublic class ProducerConsumer\n{\n    private Queue<int> _queue = new Queue<int>();\n    private readonly int _capacity = 5;\n    private readonly object _lock = new object();\n\n    public void Produce(int item)\n    {\n        lock (_lock)\n        {\n            while (_queue.Count == _capacity) // Use while loop\n            {\n                Monitor.Wait(_lock);\n            }\n            _queue.Enqueue(item);\n            Console.WriteLine($\"Produced: {item}\");\n            Monitor.PulseAll(_lock); // Use PulseAll\n        }\n    }\n\n    public int Consume()\n    {\n        lock (_lock)\n        {\n            while (_queue.Count == 0) // Use while loop\n            {\n                Monitor.Wait(_lock);\n            }\n            int item = _queue.Dequeue();\n            Console.WriteLine($\"Consumed: {item}\");\n            Monitor.PulseAll(_lock); // Use PulseAll\n            return item;\n        }\n    }\n}",
        "hint": "Always use `Monitor.Wait` inside a `while` loop to prevent spurious wakeups and ensure the condition is met. Use `Monitor.PulseAll` to wake all potentially waiting threads."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Unmanaged resources not properly released (COM objects, handles) (Lang: DotNet, Q2)",
        "buggyCode": "using System.Runtime.InteropServices;\n\npublic class MyComWrapper\n{\n    private IntPtr _comObjectPointer;\n\n    public MyComWrapper(IntPtr comPtr)\n    {\n        _comObjectPointer = comPtr;\n        // Assume comPtr points to an unmanaged COM object that needs Release()\n    }\n    // Missing finalizer or IDisposable implementation to release _comObjectPointer\n}",
        "correctCode": "using System;\nusing System.Runtime.InteropServices;\n\npublic class MyComWrapper : IDisposable\n{\n    private IntPtr _comObjectPointer;\n    private bool disposed = false;\n\n    public MyComWrapper(IntPtr comPtr)\n    {\n        _comObjectPointer = comPtr;\n    }\n\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (disposed) return;\n\n        if (disposing)\n        {\n            // Dispose managed resources here\n        }\n\n        // Release unmanaged resources\n        if (_comObjectPointer != IntPtr.Zero)\n        {\n            // Marshal.Release(_comObjectPointer); // Example for COM object\n            _comObjectPointer = IntPtr.Zero;\n        }\n        disposed = true;\n    }\n\n    ~MyComWrapper() // Finalizer for unmanaged resources\n    {\n        Dispose(false);\n    }\n}",
        "hint": "Classes managing unmanaged resources (like COM objects, file handles, network sockets) must implement `IDisposable` and optionally a finalizer to ensure proper release."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `ReaderWriterLockSlim` (Lang: DotNet, Q3)",
        "buggyCode": "using System.Threading;\n\npublic class DataStore\n{\n    private ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\n    private int _data = 0;\n\n    public int ReadData()\n    {\n        _lock.EnterReadLock();\n        int result = _data;\n        _lock.ExitReadLock();\n        return result;\n    }\n\n    public void WriteData(int value)\n    {\n        _lock.EnterWriteLock();\n        _data = value;\n        // Missing ExitWriteLock() in case of exception\n    }\n}",
        "correctCode": "using System.Threading;\n\npublic class DataStore\n{\n    private ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\n    private int _data = 0;\n\n    public int ReadData()\n    {\n        _lock.EnterReadLock();\n        try\n        {\n            return _data;\n        }\n        finally\n        {\n            _lock.ExitReadLock();\n        }\n    }\n\n    public void WriteData(int value)\n    {\n        _lock.EnterWriteLock();\n        try\n        {\n            _data = value;\n        }\n        finally\n        {\n            _lock.ExitWriteLock(); // Ensure release even on exception\n        }\n    }\n}",
        "hint": "Acquired locks (like `ReaderWriterLockSlim` reads and writes) must always be released, even if an exception occurs, using a `try-finally` block."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Capturing `this` in async lambdas without `ConfigureAwait(false)` (Lang: DotNet, Q4)",
        "buggyCode": "using System;\nusing System.Threading.Tasks;\n\npublic class MyService\n{\n    private object _data;\n\n    public MyService() {\n        _data = new object(); // Potentially large object\n    }\n\n    public async Task DoWorkAsync()\n    {\n        // This lambda captures 'this' (MyService instance)\n        await Task.Run(() => {\n            // Do some work\n        });\n        Console.WriteLine(\"Work done for \" + _data.GetHashCode());\n    }\n}",
        "correctCode": "using System;\nusing System.Threading.Tasks;\n\npublic class MyService\n{\n    private object _data;\n\n    public MyService() {\n        _data = new object();\n    }\n\n    public async Task DoWorkAsync()\n    {\n        // Use ConfigureAwait(false) to avoid capturing the current SynchronizationContext\n        // This helps prevent deadlocks and can sometimes help with GC if context isn't needed.\n        await Task.Run(() => {\n            // Do some work\n        }).ConfigureAwait(false);\n\n        // If _data is not needed after the await point, consider structuring differently\n        Console.WriteLine(\"Work done for \" + _data.GetHashCode());\n    }\n}",
        "hint": "`ConfigureAwait(false)` prevents capturing the current `SynchronizationContext` or `TaskScheduler`, which can lead to deadlocks and sometimes memory issues in specific UI/ASP.NET contexts if not understood."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `CancellationTokenSource` and `CancellationToken` (Lang: DotNet, Q5)",
        "buggyCode": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class Worker\n{\n    public async Task DoWork(CancellationToken token)\n    {\n        try\n        {\n            for (int i = 0; i < 100; i++)\n            {\n                Thread.Sleep(100); // Simulate work\n                // token.ThrowIfCancellationRequested(); // Missing check\n            }\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine(\"Work cancelled!\");\n        }\n    }\n}\n// Calling code might cancel, but worker won't respond",
        "correctCode": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class Worker\n{\n    public async Task DoWork(CancellationToken token)\n    {\n        try\n        {\n            for (int i = 0; i < 100; i++)\n            {\n                token.ThrowIfCancellationRequested(); // Check for cancellation regularly\n                Thread.Sleep(100); // Simulate work\n            }\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine(\"Work cancelled!\");\n        }\n    }\n}",
        "hint": "Long-running asynchronous operations must periodically check the `CancellationToken` to respond to cancellation requests."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Unmanaged resources not properly released (COM objects, handles) (Lang: DotNet, Q6)",
        "buggyCode": "using System.Runtime.InteropServices;\n\npublic class NativeResourceWrapper\n{\n    private IntPtr _nativeHandle; // Represents a handle to an unmanaged resource\n\n    public NativeResourceWrapper(IntPtr handle)\n    {\n        _nativeHandle = handle;\n    }\n    // No dispose pattern implemented\n}",
        "correctCode": "using System;\nusing System.Runtime.InteropServices;\n\npublic class NativeResourceWrapper : IDisposable\n{\n    private IntPtr _nativeHandle;\n    private bool _disposed = false;\n\n    public NativeResourceWrapper(IntPtr handle)\n    {\n        _nativeHandle = handle;\n    }\n\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (_disposed) return;\n\n        if (disposing)\n        {\n            // Dispose managed resources here\n        }\n\n        if (_nativeHandle != IntPtr.Zero)\n        {\n            // Release the unmanaged handle (e.g., CloseHandle, FreeLibrary, etc.)\n            // Example: CloseHandle(_nativeHandle);\n            _nativeHandle = IntPtr.Zero;\n        }\n        _disposed = true;\n    }\n\n    ~NativeResourceWrapper()\n    {\n        Dispose(false);\n    }\n}",
        "hint": "Implement `IDisposable` (and a finalizer if directly handling unmanaged memory) for classes wrapping unmanaged resources."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `Monitor.Wait` and `Monitor.Pulse` (Lang: DotNet, Q7)",
        "buggyCode": "using System.Threading;\n\npublic class BoundedBuffer\n{\n    private Queue<string> _buffer = new Queue<string>();\n    private readonly int _maxSize = 10;\n    private readonly object _lock = new object();\n\n    public void AddItem(string item)\n    {\n        lock (_lock)\n        {\n            if (_buffer.Count == _maxSize) Monitor.Wait(_lock);\n            _buffer.Enqueue(item);\n            Monitor.Pulse(_lock);\n        }\n    }\n\n    public string GetItem()\n    {\n        lock (_lock)\n        {\n            if (_buffer.Count == 0) Monitor.Wait(_lock);\n            string item = _buffer.Dequeue();\n            Monitor.Pulse(_lock);\n            return item;\n        }\n    }\n}",
        "correctCode": "using System.Threading;\nusing System.Collections.Generic;\n\npublic class BoundedBuffer\n{\n    private Queue<string> _buffer = new Queue<string>();\n    private readonly int _maxSize = 10;\n    private readonly object _lock = new object();\n\n    public void AddItem(string item)\n    {\n        lock (_lock)\n        {\n            while (_buffer.Count == _maxSize) Monitor.Wait(_lock);\n            _buffer.Enqueue(item);\n            Monitor.PulseAll(_lock); // Wake up all waiting consumers\n        }\n    }\n\n    public string GetItem()\n    {\n        lock (_lock)\n        {\n            while (_buffer.Count == 0) Monitor.Wait(_lock);\n            string item = _buffer.Dequeue();\n            Monitor.PulseAll(_lock); // Wake up all waiting producers\n            return item;\n        }\n    }\n}",
        "hint": "Use `while` loops for `Monitor.Wait` conditions to handle spurious wakeups and `Monitor.PulseAll` to unblock all potentially waiting threads."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Capturing `this` in async lambdas without `ConfigureAwait(false)` (Lang: DotNet, Q8)",
        "buggyCode": "using System;\nusing System.Threading.Tasks;\n\npublic class DataProcessor\n{\n    private List<string> _dataList = new List<string>();\n\n    public async Task ProcessLongRunningAsync()\n    {\n        await Task.Delay(100);\n        // Lambda implicitly captures `this`\n        await Task.Run(() => {\n            _dataList.Add(\"processed\");\n        });\n    }\n}",
        "correctCode": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\npublic class DataProcessor\n{\n    private List<string> _dataList = new List<string>();\n\n    public async Task ProcessLongRunningAsync()\n    {\n        // Use ConfigureAwait(false) if the continuation does not need to resume on the original context.\n        await Task.Delay(100).ConfigureAwait(false);\n        // If _dataList is needed after the await, `this` is still implicitly captured.\n        // If not, consider passing data explicitly or breaking object lifecycle.\n        await Task.Run(() => {\n            lock(_dataList) { _dataList.Add(\"processed\"); } // Also consider thread-safety for _dataList\n        }).ConfigureAwait(false);\n    }\n}",
        "hint": "`ConfigureAwait(false)` can help avoid deadlocks and sometimes subtle memory issues by not forcing the continuation back onto the original `SynchronizationContext`."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `ReaderWriterLockSlim` (Lang: DotNet, Q9)",
        "buggyCode": "using System.Threading;\n\npublic class ConcurrentCache\n{\n    private ReaderWriterLockSlim _cacheLock = new ReaderWriterLockSlim();\n    private Dictionary<string, object> _data = new Dictionary<string, object>();\n\n    public object Get(string key)\n    {\n        _cacheLock.EnterReadLock();\n        return _data[key];\n        // Missing _cacheLock.ExitReadLock() in case of key not found or other exception\n    }\n\n    public void Set(string key, object value)\n    {\n        _cacheLock.EnterWriteLock();\n        _data[key] = value;\n        // Missing _cacheLock.ExitWriteLock() in case of exception\n    }\n}",
        "correctCode": "using System.Threading;\nusing System.Collections.Generic;\n\npublic class ConcurrentCache\n{\n    private ReaderWriterLockSlim _cacheLock = new ReaderWriterLockSlim();\n    private Dictionary<string, object> _data = new Dictionary<string, object>();\n\n    public object Get(string key)\n    {\n        _cacheLock.EnterReadLock();\n        try\n        {\n            return _data[key];\n        }\n        finally\n        {\n            _cacheLock.ExitReadLock();\n        }\n    }\n\n    public void Set(string key, object value)\n    {\n        _cacheLock.EnterWriteLock();\n        try\n        {\n            _data[key] = value;\n        }\n        finally\n        {\n            _cacheLock.ExitWriteLock();\n        }\n    }\n}",
        "hint": "Always use `try-finally` blocks to ensure `ReaderWriterLockSlim` (or any lock) is released, even if an exception occurs."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Unmanaged resources not properly released (COM objects, handles) (Lang: DotNet, Q10)",
        "buggyCode": "using System;\nusing System.Runtime.InteropServices;\n\npublic class ExternalDependencyWrapper\n{\n    private IntPtr _handle; // Represents a handle to a native DLL resource\n\n    public ExternalDependencyWrapper(IntPtr h)\n    {\n        _handle = h;\n    }\n    // No IDisposable or finalizer to call ReleaseHandle on _handle\n}",
        "correctCode": "using System;\nusing System.Runtime.InteropServices;\n\npublic class ExternalDependencyWrapper : IDisposable\n{\n    private IntPtr _handle;\n    private bool _disposed = false;\n\n    public ExternalDependencyWrapper(IntPtr h)\n    {\n        _handle = h;\n    }\n\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (_disposed) return;\n\n        if (disposing)\n        {\n            // Dispose managed state (managed objects).\n        }\n\n        // Free unmanaged resources (unmanaged objects).\n        if (_handle != IntPtr.Zero)\n        {\n            // Call native function to release handle\n            // e.g., NativeMethods.CloseHandle(_handle);\n            _handle = IntPtr.Zero;\n        }\n        _disposed = true;\n    }\n\n    ~ExternalDependencyWrapper()\n    {\n        Dispose(false);\n    }\n}",
        "hint": "The Dispose Pattern (IDisposable + optional finalizer) is essential for deterministic release of unmanaged resources."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `Monitor.Wait` and `Monitor.Pulse` (Lang: DotNet, Q11)",
        "buggyCode": "using System;\nusing System.Threading;\n\npublic class ProducerConsumer\n{\n    private Queue<int> _queue = new Queue<int>();\n    private readonly int _capacity = 5;\n\n    public void Produce(int item)\n    {\n        lock (_queue)\n        {\n            if (_queue.Count == _capacity)\n            {\n                Monitor.Wait(_queue);\n            }\n            _queue.Enqueue(item);\n            Console.WriteLine($\"Produced: {item}\");\n            Monitor.Pulse(_queue);\n        }\n    }\n\n    public int Consume()\n    {\n        lock (_queue)\n        {\n            if (_queue.Count == 0)\n            {\n                Monitor.Wait(_queue);\n            }\n            int item = _queue.Dequeue();\n            Console.WriteLine($\"Consumed: {item}\");\n            Monitor.Pulse(_queue);\n            return item;\n        }\n    }\n}",
        "correctCode": "using System;\nusing System.Threading;\nusing System.Collections.Generic;\n\npublic class ProducerConsumer\n{\n    private Queue<int> _queue = new Queue<int>();\n    private readonly int _capacity = 5;\n    private readonly object _lock = new object();\n\n    public void Produce(int item)\n    {\n        lock (_lock)\n        {\n            while (_queue.Count == _capacity)\n            {\n                Monitor.Wait(_lock);\n            }\n            _queue.Enqueue(item);\n            Console.WriteLine($\"Produced: {item}\");\n            Monitor.PulseAll(_lock);\n        }\n    }\n\n    public int Consume()\n    {\n        lock (_lock)\n        {\n            while (_queue.Count == 0)\n            {\n                Monitor.Wait(_lock);\n            }\n            int item = _queue.Dequeue();\n            Console.WriteLine($\"Consumed: {item}\");\n            Monitor.PulseAll(_lock);\n            return item;\n        }\n    }\n}",
        "hint": "Always use `Monitor.Wait` inside a `while` loop to prevent spurious wakeups and ensure the condition is met. Use `Monitor.PulseAll` to wake all potentially waiting threads."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Unmanaged resources not properly released (COM objects, handles) (Lang: DotNet, Q12)",
        "buggyCode": "using System.Runtime.InteropServices;\n\npublic class MyComWrapper\n{\n    private IntPtr _comObjectPointer;\n\n    public MyComWrapper(IntPtr comPtr)\n    {\n        _comObjectPointer = comPtr;\n    }\n}",
        "correctCode": "using System;\nusing System.Runtime.InteropServices;\n\npublic class MyComWrapper : IDisposable\n{\n    private IntPtr _comObjectPointer;\n    private bool disposed = false;\n\n    public MyComWrapper(IntPtr comPtr)\n    {\n        _comObjectPointer = comPtr;\n    }\n\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (disposed) return;\n\n        if (disposing)\n        {\n        }\n\n        if (_comObjectPointer != IntPtr.Zero)\n        {\n            _comObjectPointer = IntPtr.Zero;\n        }\n        disposed = true;\n    }\n\n    ~MyComWrapper()\n    {\n        Dispose(false);\n    }\n}",
        "hint": "Classes managing unmanaged resources must implement `IDisposable` and optionally a finalizer to ensure proper release."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `ReaderWriterLockSlim` (Lang: DotNet, Q13)",
        "buggyCode": "using System.Threading;\n\npublic class DataStore\n{\n    private ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\n    private int _data = 0;\n\n    public int ReadData()\n    {\n        _lock.EnterReadLock();\n        int result = _data;\n        _lock.ExitReadLock();\n        return result;\n    }\n\n    public void WriteData(int value)\n    {\n        _lock.EnterWriteLock();\n        _data = value;\n    }\n}",
        "correctCode": "using System.Threading;\n\npublic class DataStore\n{\n    private ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\n    private int _data = 0;\n\n    public int ReadData()\n    {\n        _lock.EnterReadLock();\n        try\n        {\n            return _data;\n        }\n        finally\n        {\n            _lock.ExitReadLock();\n        }\n    }\n\n    public void WriteData(int value)\n    {\n        _lock.EnterWriteLock();\n        try\n        {\n            _data = value;\n        }\n        finally\n        {\n            _lock.ExitWriteLock();\n        }\n    }\n}",
        "hint": "Acquired locks must always be released, even if an exception occurs, using a `try-finally` block."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Capturing `this` in async lambdas without `ConfigureAwait(false)` (Lang: DotNet, Q14)",
        "buggyCode": "using System;\nusing System.Threading.Tasks;\n\npublic class MyService\n{\n    private object _data;\n\n    public MyService() { _data = new object(); }\n\n    public async Task DoWorkAsync()\n    {\n        await Task.Run(() => { });\n        Console.WriteLine(\"Work done for \" + _data.GetHashCode());\n    }\n}",
        "correctCode": "using System;\nusing System.Threading.Tasks;\n\npublic class MyService\n{\n    private object _data;\n\n    public MyService() { _data = new object(); }\n\n    public async Task DoWorkAsync()\n    {\n        await Task.Run(() => { }).ConfigureAwait(false);\n        Console.WriteLine(\"Work done for \" + _data.GetHashCode());\n    }\n}",
        "hint": "`ConfigureAwait(false)` can help prevent deadlocks and subtle memory issues by not capturing the `SynchronizationContext`."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `CancellationTokenSource` and `CancellationToken` (Lang: DotNet, Q15)",
        "buggyCode": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class Worker\n{\n    public async Task DoWork(CancellationToken token)\n    {\n        try\n        {\n            for (int i = 0; i < 100; i++)\n            {\n                Thread.Sleep(100);\n            }\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine(\"Work cancelled!\");\n        }\n    }\n}",
        "correctCode": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class Worker\n{\n    public async Task DoWork(CancellationToken token)\n    {\n        try\n        {\n            for (int i = 0; i < 100; i++)\n            {\n                token.ThrowIfCancellationRequested();\n                Thread.Sleep(100);\n            }\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine(\"Work cancelled!\");\n        }\n    }\n}",
        "hint": "Long-running async operations must periodically check the `CancellationToken`."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Unmanaged resources not properly released (COM objects, handles) (Lang: DotNet, Q16)",
        "buggyCode": "using System.Runtime.InteropServices;\n\npublic class NativeResourceWrapper\n{\n    private IntPtr _nativeHandle;\n\n    public NativeResourceWrapper(IntPtr handle)\n    {\n        _nativeHandle = handle;\n    }\n}",
        "correctCode": "using System;\nusing System.Runtime.InteropServices;\n\npublic class NativeResourceWrapper : IDisposable\n{\n    private IntPtr _nativeHandle;\n    private bool _disposed = false;\n\n    public NativeResourceWrapper(IntPtr handle)\n    {\n        _nativeHandle = handle;\n    }\n\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (_disposed) return;\n\n        if (disposing)\n        {\n        }\n\n        if (_nativeHandle != IntPtr.Zero)\n        {\n            _nativeHandle = IntPtr.Zero;\n        }\n        _disposed = true;\n    }\n\n    ~NativeResourceWrapper()\n    {\n        Dispose(false);\n    }\n}",
        "hint": "Implement `IDisposable` and a finalizer for classes wrapping unmanaged resources."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `Monitor.Wait` and `Monitor.Pulse` (Lang: DotNet, Q17)",
        "buggyCode": "using System.Threading;\n\npublic class BoundedBuffer\n{\n    private Queue<string> _buffer = new Queue<string>();\n    private readonly int _maxSize = 10;\n    private readonly object _lock = new object();\n\n    public void AddItem(string item)\n    {\n        lock (_lock)\n        {\n            if (_buffer.Count == _maxSize) Monitor.Wait(_lock);\n            _buffer.Enqueue(item);\n            Monitor.Pulse(_lock);\n        }\n    }\n\n    public string GetItem()\n    {\n        lock (_lock)\n        {\n            if (_buffer.Count == 0) Monitor.Wait(_lock);\n            string item = _buffer.Dequeue();\n            Monitor.Pulse(_lock);\n            return item;\n        }\n    }\n}",
        "correctCode": "using System.Threading;\nusing System.Collections.Generic;\n\npublic class BoundedBuffer\n{\n    private Queue<string> _buffer = new Queue<string>();\n    private readonly int _maxSize = 10;\n    private readonly object _lock = new object();\n\n    public void AddItem(string item)\n    {\n        lock (_lock)\n        {\n            while (_buffer.Count == _maxSize) Monitor.Wait(_lock);\n            _buffer.Enqueue(item);\n            Monitor.PulseAll(_lock);\n        }\n    }\n\n    public string GetItem()\n    {\n        lock (_lock)\n        {\n            while (_buffer.Count == 0) Monitor.Wait(_lock);\n            string item = _buffer.Dequeue();\n            Monitor.PulseAll(_lock);\n            return item;\n        }\n    }\n}",
        "hint": "Use `while` loops for `Monitor.Wait` and `Monitor.PulseAll` for reliable producer-consumer patterns."
      },
      {
        "language": "DotNet",
        "bugType": "Memory Leak",
        "description": "Capturing `this` in async lambdas without `ConfigureAwait(false)` (Lang: DotNet, Q18)",
        "buggyCode": "using System;\nusing System.Threading.Tasks;\n\npublic class DataProcessor\n{\n    private List<string> _dataList = new List<string>();\n\n    public async Task ProcessLongRunningAsync()\n    {\n        await Task.Delay(100);\n        await Task.Run(() => {\n            _dataList.Add(\"processed\");\n        });\n    }\n}",
        "correctCode": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\npublic class DataProcessor\n{\n    private List<string> _dataList = new List<string>();\n\n    public async Task ProcessLongRunningAsync()\n    {\n        await Task.Delay(100).ConfigureAwait(false);\n        await Task.Run(() => {\n            lock(_dataList) { _dataList.Add(\"processed\"); }\n        }).ConfigureAwait(false);\n    }\n}",
        "hint": "`ConfigureAwait(false)` can prevent deadlocks and subtle memory issues by not capturing the `SynchronizationContext`."
      },
      {
        "language": "DotNet",
        "bugType": "Concurrency Issue",
        "description": "Incorrect use of `ReaderWriterLockSlim` (Lang: DotNet, Q19)",
        "buggyCode": "using System.Threading;\nusing System.Collections.Generic;\n\npublic class ConcurrentCache\n{\n    private ReaderWriterLockSlim _cacheLock = new ReaderWriterLockSlim();\n    private Dictionary<string, object> _data = new Dictionary<string, object>();\n\n    public object Get(string key)\n    {\n        _cacheLock.EnterReadLock();\n        return _data[key];\n    }\n\n    public void Set(string key, object value)\n    {\n        _cacheLock.EnterWriteLock();\n        _data[key] = value;\n    }\n}",
        "correctCode": "using System.Threading;\nusing System.Collections.Generic;\n\npublic class ConcurrentCache\n{\n    private ReaderWriterLockSlim _cacheLock = new ReaderWriterLockSlim();\n    private Dictionary<string, object> _data = new Dictionary<string, object>();\n\n    public object Get(string key)\n    {\n        _cacheLock.EnterReadLock();\n        try\n        {\n            return _data[key];\n        }\n        finally\n        {\n            _cacheLock.ExitReadLock();\n        }\n    }\n\n    public void Set(string key, object value)\n    {\n        _cacheLock.EnterWriteLock();\n        try\n        {\n            _data[key] = value;\n        }\n        finally\n        {\n            _cacheLock.ExitWriteLock();\n        }\n    }\n}",
        "hint": "Always use `try-finally` blocks to ensure `ReaderWriterLockSlim` (or any lock) is released, even if an exception occurs."
     }
    ]
  }
}